<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
      Minicurso: Aprender React com Jogo de Cartas - Conceitos Fundamentais
    </title>
    <link rel="stylesheet" href="style.css" />

    <!-- Fontes -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap"
      rel="stylesheet"
    />
  </head>

  <body>
    <nav id="navbar" class="no-print">
      <img src="./logo.png" alt="logoInova" class="logo no-print" />
      <a href="#introducao" class="nav-link">Introdução</a>
      <a href="#typescript-conceito" class="nav-link">TypeScript</a>
      <a href="#react-conceito" class="nav-link">React</a>
      <a href="#componentes-conceito" class="nav-link">Componentes</a>
      <a href="#jsx-conceito" class="nav-link">JSX</a>
      <a href="#props-conceito" class="nav-link">Props</a>
      <a href="#estado-conceito" class="nav-link">Estado</a>
      <a href="#hooks-conceito" class="nav-link">Hooks</a>
      <a href="#instalacao" class="nav-link">Instalação</a>
      <a href="#implementacao-jogo" class="nav-link">Implementação</a>
      <a href="#conclusao" class="nav-link">Conclusão</a>
    </nav>

    <main id="main-doc">
      <h1>Minicurso: Aprender REACT fazendo um jogo de cartas</h1>

      <section id="introducao" class="main-section">
        <h2>Introdução: Aprendendo Conceitos Primeiro</h2>
        <p>
          Neste minicurso, vamos adotar uma abordagem
          <strong>conceitual primeiro</strong>. Antes de colocar a mão na massa,
          você vai entender profundamente os conceitos do React e TypeScript. Só
          depois partiremos para a implementação do nosso jogo de cartas.
        </p>

        <div class="learning-path">
          <h3>Nosso Roteiro de Aprendizado:</h3>
          <ol>
            <li><strong>Fundamentos</strong>: TypeScript e React</li>
            <li><strong>Blocos de Construção</strong>: Componentes e JSX</li>
            <li><strong>Comunicação</strong>: Props e Estado</li>
            <li><strong>Ferramentas</strong>: Hooks do React</li>
            <li><strong>Prática</strong>: Implementação do Jogo</li>
          </ol>
        </div>
      </section>

      <!-- SEÇÃO 1: TYPESCRIPT -->
      <section id="typescript-conceito" class="main-section">
        <h2>TypeScript: JavaScript com Superpoderes</h2>

        <div class="analogy">
          <h3>Analogia: Receita de Bolo vs Instruções Vagas</h3>
          <div class="analogy-item">
            <p>
              <strong>JavaScript (Instruções Vagas):</strong><br />
              "Misture ingredientes e asse" - Pode dar certo, mas também pode
              dar muito errado!
            </p>
          </div>
          <div class="analogy-item">
            <p>
              <strong>TypeScript (Receita Detalhada):</strong><br />
              "Misture 2 xícaras de farinha, 3 ovos, asse a 180°C por 30min" -
              Resultado previsível e consistente!
            </p>
          </div>
        </div>

        <h3>O que é TypeScript?</h3>
        <p>
          TypeScript é um <strong>superset</strong> do JavaScript que adiciona
          <strong>tipagem estática</strong>. Isso significa que podemos definir
          tipos para nossas variáveis, funções e objetos, permitindo que erros
          sejam detectados durante o desenvolvimento, antes mesmo de executar o
          código.
        </p>

        <h3>Benefícios do TypeScript</h3>
        <ul>
          <li>
            <strong>Detecção de Erros Antecipada</strong>: Encontra bugs durante
            a escrita do código
          </li>
          <li>
            <strong>Autocomplete Inteligente</strong>: Editores sugerem
            propriedades e métodos corretos
          </li>
          <li>
            <strong>Documentação Automática</strong>: Os tipos servem como
            documentação viva
          </li>
          <li>
            <strong>Refatoração Segura</strong>: Mudanças no código são mais
            seguras e previsíveis
          </li>
        </ul>

        <h3>Exemplos Práticos de TypeScript</h3>

        <div class="code-container">
          <pre>
// JavaScript (sem tipos)
function calcularArea(raio) {
    return Math.PI * raio * raio;
}

// TypeScript (com tipos)
function calcularArea(raio: number): number {
    return Math.PI * raio * raio;
}

// ⚠️ Isso geraria um erro em TypeScript:
// calcularArea("5"); // ERRO: Argumento do tipo string não é atribuível ao tipo number</pre
          >
          <button class="copy-btn no-print">Copiar</button>
        </div>

        <div class="code-container">
          <pre>
// Tipos básicos
let nome: string = "João";
let idade: number = 25;
let ativo: boolean = true;
let numeros: number[] = [1, 2, 3];
let qualquer: any = "pode ser qualquer coisa";

// Interface para definir a forma de um objeto
interface Usuario {
    id: number;
    nome: string;
    email: string;
    ativo?: boolean; // Propriedade opcional
}

// Usando a interface
const usuario: Usuario = {
    id: 1,
    nome: "Maria",
    email: "maria@email.com"
    // ativo é opcional, então não precisa ser definido
};

// Função com tipos
function cumprimentar(usuario: Usuario): string {
    return `Olá, ${usuario.nome}!`;
}

// TypeScript previne erros:
// usuario.idade = 30; // ERRO: Propriedade 'idade' não existe no tipo 'Usuario'
// cumprimentar("texto"); // ERRO: Argumento do tipo string não é atribuível</pre
          >
          <button class="copy-btn no-print">Copiar</button>
        </div>
      </section>

      <!-- SEÇÃO 2: REACT -->
      <section id="react-conceito" class="main-section">
        <h2>React: A Biblioteca para Interfaces</h2>

        <div class="analogy">
          <h3>Analogia: Fábrica de Carros vs Montagem Manual</h3>
          <div class="analogy-item">
            <p>
              <strong>HTML/CSS/JS Tradicional (Montagem Manual):</strong><br />
              Como montar um carro peça por peça manualmente - trabalhoso e
              propenso a erros.
            </p>
          </div>
          <div class="analogy-item">
            <p>
              <strong>React (Linha de Montagem):</strong><br />
              Como uma fábrica automatizada - componentes padronizados que se
              encaixam perfeitamente.
            </p>
          </div>
        </div>

        <h3>O que é React?</h3>
        <p>
          React é uma <strong>biblioteca JavaScript</strong> para construir
          interfaces de usuário. Sua principal característica é o conceito de
          <strong>componentes</strong> - pedaços de código reutilizáveis que
          representam partes da interface.
        </p>

        <h3>Princípios Fundamentais do React</h3>
        <ul>
          <li>
            <strong>Componentes</strong>: Divide o sistema em partes
            independentes e reutilizáveis
          </li>
          <li>
            <strong>Props</strong>: Passe dados para os componentes (entradas)
          </li>
          <li>
            <strong>Estado</strong>: Gerencia de dados que mudam com o tempo
          </li>
          <li>
            <strong>Renderização Declarativa</strong>: Descreve O QUE o sistema
            deve fazer e não COMO fazer
          </li>
        </ul>

        <h3>Declarativo vs Imperativo</h3>

        <div class="code-container">
          <pre>
// ABORDAGEM IMPERATIVA (Vanilla JavaScript)
// "COMO fazer" - passo a passo manual
function atualizarContadorImperativo() {
    const elemento = document.getElementById('contador');
    const valorAtual = parseInt(elemento.textContent);
    const novoValor = valorAtual + 1;
    elemento.textContent = novoValor.toString();
    
    if (novoValor > 5) {
        elemento.classList.add('destaque');
    } else {
        elemento.classList.remove('destaque');
    }
}

// ABORDAGEM DECLARATIVA (React)
// "O QUE queremos" - resultado desejado
function ContadorDeclarativo() {
    const [valor, setValor] = useState(0);
    
    const incrementar = () => {
        setValor(valor + 1);
    };
    
    return (
        &lt;div className={valor > 5 ? 'destaque' : ''}&gt;
            &lt;span&gt;{valor}&lt;/span&gt;
            &lt;button onClick={incrementar}&gt;Incrementar&lt;/button&gt;
        &lt;/div&gt;
    );
}</pre
          >
          <button class="copy-btn no-print">Copiar</button>
        </div>

        <h3>Exemplo: Componente Básico</h3>
        <div class="code-container">
          <pre>
// Componente React mais simples possível
function Saudacao() {
    return &lt;h1&gt;Olá, Mundo!&lt;/h1&gt;;
}

// Componente com lógica simples
function Relogio() {
    const [hora, setHora] = useState(new Date());
    
    useEffect(() => {
        const timer = setInterval(() => {
            setHora(new Date());
        }, 1000);
        
        return () => clearInterval(timer);
    }, []);
    
    return (
        &lt;div&gt;
            &lt;h2&gt;Hora atual:&lt;/h2&gt;
            &lt;p&gt;{hora.toLocaleTimeString()}&lt;/p&gt;
        &lt;/div&gt;
    );
}</pre
          >
          <button class="copy-btn no-print">Copiar</button>
        </div>
      </section>

      <!-- SEÇÃO 3: COMPONENTES -->
      <section id="componentes-conceito" class="main-section">
        <h2>Componentes: Blocos de Construção do React</h2>

        <div class="analogy">
          <h3>Analogia: Peças de Lego vs Escultura em Pedra</h3>
          <div class="analogy-item">
            <p>
              <strong>Desenvolvimento Tradicional (Escultura):</strong><br />
              Como esculpir uma estátua em mármore - se errar, tem que começar
              de novo.
            </p>
          </div>
          <div class="analogy-item">
            <p>
              <strong>Componentes React (Lego):</strong><br />
              Como montar com peças de Lego - componentes encaixáveis,
              reutilizáveis e modulares.
            </p>
          </div>
        </div>

        <h3>O que são Componentes?</h3>
        <p>
          Componentes são <strong>funções JavaScript</strong> que retornam
          elementos de interface (JSX). Eles permitem dividir a UI em partes
          independentes, reutilizáveis e de responsabilidade única.
        </p>

        <h3>Exemplo: Componente Botão Reutilizável</h3>
        <div class="code-container">
          <pre>
// Componente de UI (Presentacional)
interface BotaoProps {
    children: React.ReactNode;
    onClick?: () => void;
    tipo?: 'primario' | 'secundario' | 'perigo';
    desabilitado?: boolean;
    className?: string;
}

function Botao({ 
    children, 
    onClick, 
    tipo = 'primario',
    desabilitado = false,
    className = ''
}: BotaoProps) {
    const classes = `botao botao-${tipo} ${desabilitado ? 'botao-desabilitado' : ''} ${className}`;
    
    return (
        &lt;button 
            className={classes.trim()}
            onClick={onClick}
            disabled={desabilitado}
        &gt;
            {children}
        &lt;/button&gt;
    );
}

// Uso do componente
function App() {
    const [contador, setContador] = useState(0);
    
    return (
        &lt;div&gt;
            &lt;Botao 
                tipo="primario"
                onClick={() => setContador(contador + 1)}
            &gt;
                Incrementar: {contador}
            &lt;/Botao&gt;
            
            &lt;Botao 
                tipo="secundario"
                onClick={() => setContador(0)}
            &gt;
                Resetar
            &lt;/Botao&gt;
            
            &lt;Botao 
                tipo="perigo"
                desabilitado={contador === 0}
                onClick={() => setContador(contador - 1)}
            &gt;
                Decrementar
            &lt;/Botao&gt;
        &lt;/div&gt;
    );
}</pre
          >
          <button class="copy-btn no-print">Copiar</button>
        </div>
      </section>

      <!-- SEÇÃO 4: JSX -->
      <section id="jsx-conceito" class="main-section">
        <h2>JSX: HTML no JavaScript</h2>

        <div class="analogy">
          <h3>Analogia: Cozinha Separada vs Cozinha Integrada</h3>
          <div class="analogy-item">
            <p>
              <strong>HTML/JS Separados (Cozinhas Separadas):</strong><br />
              Como ter a cozinha em um cômodo e os ingredientes em outro - muita
              ida e volta.
            </p>
          </div>
          <div class="analogy-item">
            <p>
              <strong>JSX (Cozinha Integrada):</strong><br />
              Como ter tudo organizado no mesmo ambiente - eficiente e prático.
            </p>
          </div>
        </div>

        <h3>O que é JSX?</h3>
        <p>
          JSX é uma <strong>extensão de sintaxe</strong> do JavaScript que
          permite escrever HTML dentro do código JavaScript. É como o React
          "descreve" como a interface deve ficar.
        </p>

        <h3>Regras do JSX</h3>
        <ul>
          <li><strong>className</strong> em vez de <code>class</code></li>
          <li>
            <strong>Tags devem ser fechadas</strong> (<code>&lt;img /&gt;</code
            >, <code>&lt;br /&gt;</code>)
          </li>
          <li>
            <strong>Um elemento pai</strong> por componente (ou usar
            <code>&lt;&gt;&lt;/&gt;</code> - Fragment)
          </li>
          <li><strong>JavaScript entre {}</strong> para expressões</li>
          <li><strong>style</strong> recebe um objeto em vez de string</li>
        </ul>

        <h3>Exemplos de JSX</h3>

        <div class="code-container">
          <pre>
// JSX Básico
function Saudacao({ nome, idade }) {
    return (
        &lt;div className="saudacao"&gt;
            &lt;h1&gt;Olá, {nome}!&lt;/h1&gt;
            &lt;p&gt;Você tem {idade} anos&lt;/p&gt;
        &lt;/div&gt;
    );
}

// JSX com Eventos
function ContadorInterativo() {
    const [valor, setValor] = useState(0);
    
    const handleClick = (incremento: number) => {
        setValor(valor + incremento);
    };
    
    return (
        &lt;div&gt;
            &lt;h3&gt;Contador: {valor}&lt;/h3&gt;
            &lt;button onClick={() => handleClick(1)}&gt;
                +1
            &lt;/button&gt;
            &lt;button onClick={() => handleClick(-1)}&gt;
                -1
            &lt;/button&gt;
            &lt;button onClick={() => setValor(0)}&gt;
                Reset
            &lt;/button&gt;
        &lt;/div&gt;
    );
}</pre
          >
          <button class="copy-btn no-print">Copiar</button>
        </div>
      </section>

      <!-- SEÇÃO 5: PROPS -->
      <section id="props-conceito" class="main-section">
        <h2>Props: Comunicação entre Componentes</h2>

        <div class="analogy">
          <h3>Analogia: Mensagem vs Telepatia</h3>
          <div class="analogy-item">
            <p>
              <strong>Sem Props (Telepatia):</strong><br />
              Como esperar que componentes adivinhem o que precisam - não
              funciona!
            </p>
          </div>
          <div class="analogy-item">
            <p>
              <strong>Com Props (Mensagem):</strong><br />
              Como enviar uma mensagem com instruções claras - previsível e
              confiável.
            </p>
          </div>
        </div>

        <h3>O que são Props?</h3>
        <p>
          Props (abreviação de <strong>properties</strong>) são o mecanismo do
          React para passar dados de um componente pai para um componente filho.
          São <strong>imutáveis</strong> - o componente filho não pode
          alterá-las.
        </p>

        <h3>Características das Props</h3>
        <ul>
          <li><strong>Unidirecionais</strong>: Só fluem de pai para filho</li>
          <li><strong>Imutáveis</strong>: Componente filho não pode alterar</li>
          <li>
            <strong>Tipáveis</strong>: Podemos definir tipos com TypeScript
          </li>
          <li><strong>Configuráveis</strong>: Podem ter valores padrão</li>
        </ul>

        <h3>Exemplo Detalhado: Props em Ação</h3>

        <div class="code-container">
          <pre>
// Definindo as props do componente
interface BotaoProps {
  texto: string;
  cor?: string; // opcional
  onClick: () => void;
}

// Componente usando as props
function Botao({ texto, cor = "azul", onClick }: BotaoProps) {
  return (
    &lt;button 
      style={{ backgroundColor: cor }}
      onClick={onClick}
    &gt;
      {texto}
    &lt;/button&gt;
  );
}

// Como usar o componente
function App() {
  const handleClick = () => {
    console.log("Botão clicado!");
  };

  return (
    &lt;div&gt;
      &lt;Botao 
        texto="Clique aqui" 
        onClick={handleClick} 
      /&gt;
      
      &lt;Botao 
        texto="Delete" 
        cor="vermelho" 
        onClick={handleClick} 
      /&gt;
    &lt;/div&gt;
  );
}</pre
          >
          <button class="copy-btn no-print">Copiar</button>
        </div>
      </section>

      <!-- SEÇÃO 6: ESTADO -->
      <section id="estado-conceito" class="main-section">
        <h2>Estado: Dados que Mudam com o Tempo</h2>

        <div class="analogy">
          <h3>Analogia: Memória vs Ação Instantânea</h3>
          <div class="analogy-item">
            <p>
              <strong>Sem Estado (Ação Instantânea):</strong><br />
              Como uma conversa onde todos esquecem o que foi dito - sem
              continuidade.
            </p>
          </div>
          <div class="analogy-item">
            <p>
              <strong>Com Estado (Memória):</strong><br />
              Como um diário que guarda todas as experiências - contexto e
              histórico.
            </p>
          </div>
        </div>

        <h3>O que é Estado?</h3>
        <p>
          Estado representa os <strong>dados que podem mudar</strong> durante a
          vida de um componente. Quando o estado muda, o React automaticamente
          <strong>re-renderiza</strong> o componente para refletir essas
          mudanças.
        </p>

        <h3>Quando usar Estado?</h3>
        <ul>
          <li>
            <strong>Dados dinâmicos</strong>: Contadores, formulários, filtros
            ativos
          </li>
          <li>
            <strong>Interações do usuário</strong>: Itens selecionados, opções
            ativas, menus abertos
          </li>
          <li>
            <strong>Dados de API</strong>: Listas de usuários, informações do
            servidor
          </li>
          <li>
            <strong>Estado da UI</strong>: Loading, erros, temas claro/escuro
          </li>
        </ul>

        <h3>useState: O Hook Básico de Estado</h3>

        <div class="code-container">
          <pre>// ANTES (variável normal - NÃO FUNCIONA)
let contador = 0;
contador = 1; // A tela NÃO atualiza

// DEPOIS (estado - FUNCIONA)
const [contador, setContador] = useState(0);
setContador(1); // A tela atualiza AUTOMATICAMENTE</pre
          >
          <button class="copy-btn no-print">Copiar</button>
        </div>

        <h3>Estado Local vs Global</h3>

        <div class="state-types">
          <div class="state-type">
            <h4>Estado Local</h4>
            <p>
              <strong>Uso:</strong> Dados usados apenas por um componente<br />
              <strong>Exemplo:</strong> Input de formulário, menu
              aberto/fechado, loading local<br />
              <strong>Hook:</strong> <code>useState</code>
            </p>
          </div>

          <div class="state-type">
            <h4>Estado Global</h4>
            <p>
              <strong>Uso:</strong> Dados compartilhados entre vários
              componentes<br />
              <strong>Exemplo:</strong> Usuário logado, tema da aplicação,
              carrinho de compras<br />
              <strong>Soluções:</strong> Context API
            </p>
          </div>
        </div>
      </section>

      <!-- SEÇÃO 7: HOOKS -->
      <section id="hooks-conceito" class="main-section">
        <h2>Hooks: Funcionalidades do React</h2>

        <div class="analogy">
          <h3>Analogia: Kit de Ferramentas vs Inventar Soluções</h3>
          <div class="analogy-item">
            <p>
              <strong>Sem Hooks (Inventar Soluções):</strong><br />
              Como tentar consertar algo sem as ferramentas certas - você acaba
              usando soluções improvisadas, o código fica complexo e difícil de
              manter.
            </p>
          </div>
          <div class="analogy-item">
            <p>
              <strong>Com Hooks (Kit de Ferramentas):</strong><br />
              Como ter uma caixa de ferramentas organizada - cada problema tem a
              ferramenta específica para resolvê-lo de forma eficiente e
              padronizada.
            </p>
          </div>
        </div>

        <h3>O que são Hooks?</h3>
        <p>
          Hooks são <strong>funções especiais</strong> que permitem "conectar"
          funcionalidades do React a componentes funcionais. Eles sempre começam
          com <code>use</code> (useState, useEffect, etc.) e permitem usar
          estado e outras características do React sem escrever uma classe.
        </p>

        <h3>Hooks Principais</h3>

        <div class="hooks-grid">
          <div class="hook-item">
            <h4>useState</h4>
            <p>
              <strong>Função:</strong> Gerenciar estado local em componentes
              funcionais<br />
              <strong>Uso:</strong> Contadores, formulários, toggle states<br />
              <strong>Retorna:</strong> [valor, funçãoParaAtualizar]<br />
              <strong>Exemplo:</strong> const [count, setCount] = useState(0)
            </p>
            <div class="hook-details">
              <p>
                <strong>Quando usar:</strong> Para qualquer estado simples que
                precise ser atualizado e cause re-renderização do componente.
              </p>
            </div>
          </div>

          <div class="hook-item">
            <h4>useEffect</h4>
            <p>
              <strong>Função:</strong> Executar efeitos colaterais<br />
              <strong>Uso:</strong> API calls, subscriptions, timers<br />
              <strong>Substitui:</strong> componentDidMount, componentDidUpdate,
              componentWillUnmount<br />
              <strong>Exemplo:</strong> useEffect(() => { ... }, [dependencias])
            </p>
            <div class="hook-details">
              <p>
                <strong>Quando usar:</strong> Para operações que interagem com o
                mundo externo ou precisam sincronizar com mudanças de
                estado/props.
              </p>
            </div>
          </div>

          <div class="hook-item">
            <h4>useReducer</h4>
            <p>
              <strong>Função:</strong> Estado complexo com ações<br />
              <strong>Uso:</strong> Formulários complexos, estado com lógica
              elaborada<br />
              <strong>Padrão:</strong> (state, action) => newState<br />
              <strong>Exemplo:</strong> const [state, dispatch] =
              useReducer(reducer, initialState)
            </p>
            <div class="hook-details">
              <p>
                <strong>Quando usar:</strong> Quando o estado tem lógica
                complexa ou quando o próximo estado depende do anterior.
              </p>
            </div>
          </div>

          <div class="hook-item">
            <h4>useRef</h4>
            <p>
              <strong>Função:</strong> Acessar elementos DOM e persistir
              valores<br />
              <strong>Uso:</strong> Foco em inputs, medições, valores
              mutáveis<br />
              <strong>Característica:</strong> Não causa re-renderização<br />
              <strong>Exemplo:</strong> const inputRef = useRef(null)
            </p>
            <div class="hook-details">
              <p>
                <strong>Quando usar:</strong> Para acessar elementos DOM
                diretamente ou manter valores que não devem disparar
                re-renderizações.
              </p>
            </div>
          </div>
        </div>

        <h3>Explicação Detalhada: useEffect</h3>
        <p>
          O <code>useEffect</code> é usado para executar efeitos colaterais em
          componentes funcionais. Ele substitui <code>componentDidMount</code>,
          <code>componentDidUpdate</code> e
          <code>componentWillUnmount</code>
          dos componentes de classe.
        </p>

        <div class="useEffect-examples">
          <h4>Padrões Comuns do useEffect:</h4>
          <ul>
            <li>
              <strong>[] (array vazio):</strong> Executa apenas uma vez após a
              montagem do componente
            </li>
            <li>
              <strong>[var1, var2]:</strong> Executa sempre que alguma das
              dependências mudar
            </li>
            <li>
              <strong>Sem array:</strong> Executa após cada renderização (não
              recomendado)
            </li>
            <li>
              <strong>Função de cleanup:</strong> Retorna uma função para limpar
              recursos
            </li>
          </ul>
        </div>

        <h3>Exemplo: useEffect para Diferentes Cenários</h3>

        <div class="code-container">
          <pre>
import { useState, useEffect, useRef } from 'react';

// Exemplo 1: useEffect para API call (componentDidMount)
function ListaUsuarios() {
    const [usuarios, setUsuarios] = useState([]);
    const [carregando, setCarregando] = useState(true);
    const [erro, setErro] = useState(null);
    
    // Executa apenas uma vez quando o componente monta
    useEffect(() => {
        async function carregarUsuarios() {
            try {
                setCarregando(true);
                const resposta = await fetch('https://jsonplaceholder.typicode.com/users');
                const dados = await resposta.json();
                setUsuarios(dados);
            } catch (err) {
                setErro('Erro ao carregar usuários');
            } finally {
                setCarregando(false);
            }
        }
        
        carregarUsuarios();
    }, []); // Array de dependências vazio = executa apenas uma vez
    
    if (carregando) return &lt;div&gt;Carregando...&lt;/div&gt;;
    if (erro) return &lt;div&gt;{erro}&lt;/div&gt;;
    
    return (
        &lt;ul&gt;
            {usuarios.map(usuario => (
                &lt;li key={usuario.id}&gt;{usuario.name}&lt;/li&gt;
            ))}
        &lt;/ul&gt;
    );
}

// Exemplo 2: useEffect com dependências (componentDidUpdate)
function ContadorComHistorico() {
    const [contador, setContador] = useState(0);
    const [historico, setHistorico] = useState([]);
    
    // Executa sempre que 'contador' mudar
    useEffect(() => {
        setHistorico(prev => [...prev, contador]);
        console.log(`Contador atualizado para: ${contador}`);
    }, [contador]); // Dependência: executa quando 'contador' muda
    
    return (
        &lt;div&gt;
            &lt;h2&gt;Contador: {contador}&lt;/h2&gt;
            &lt;button onClick={() => setContador(c => c + 1)}&gt;
                Incrementar
            &lt;/button&gt;
            &lt;h3&gt;Histórico:&lt;/h3&gt;
            &lt;ul&gt;
                {historico.map((valor, index) => (
                    &lt;li key={index}&gt;{valor}&lt;/li&gt;
                ))}
            &lt;/ul&gt;
        &lt;/div&gt;
    );
}

// Exemplo 3: useEffect com cleanup (componentWillUnmount)
function RelogioComCleanup() {
    const [hora, setHora] = useState(new Date());
    
    useEffect(() => {
        const timerID = setInterval(() => {
            setHora(new Date());
        }, 1000);
        
        // Função de cleanup - executa quando o componente desmonta
        return () => {
            console.log('Limpando timer...');
            clearInterval(timerID);
        };
    }, []); // Array vazio = setup e cleanup uma vez
    
    return &lt;div&gt;Hora atual: {hora.toLocaleTimeString()}&lt;/div&gt;;
}

// Exemplo 4: useRef para acessar elementos DOM
function InputComFoco() {
    const inputRef = useRef(null);
    const [valor, setValor] = useState('');
    
    const focarInput = () => {
        // Acessa o elemento DOM diretamente
        inputRef.current.focus();
        inputRef.current.select();
    };
    
    return (
        &lt;div&gt;
            &lt;input
                ref={inputRef}
                value={valor}
                onChange={(e) => setValor(e.target.value)}
                placeholder="Digite algo..."
            /&gt;
            &lt;button onClick={focarInput}&gt;
                Focar no Input
            &lt;/button&gt;
        &lt;/div&gt;
    );
}

// Exemplo 5: useReducer para estado complexo
function reducer(state, action) {
    switch (action.type) {
        case 'incrementar':
            return { contador: state.contador + 1 };
        case 'decrementar':
            return { contador: state.contador - 1 };
        case 'resetar':
            return { contador: 0 };
        default:
            throw new Error(`Ação desconhecida: ${action.type}`);
    }
}

function ContadorReducer() {
    const [state, dispatch] = useReducer(reducer, { contador: 0 });
    
    return (
        &lt;div&gt;
            &lt;h2&gt;Contador: {state.contador}&lt;/h2&gt;
            &lt;button onClick={() => dispatch({ type: 'incrementar' })}&gt;
                +
            &lt;/button&gt;
            &lt;button onClick={() => dispatch({ type: 'decrementar' })}&gt;
                -
            &lt;/button&gt;
            &lt;button onClick={() => dispatch({ type: 'resetar' })}&gt;
                Reset
            &lt;/button&gt;
        &lt;/div&gt;
    );
}</pre
          >
          <button class="copy-btn no-print">Copiar</button>
        </div>

        <div class="best-practices">
          <h3>Boas Práticas com Hooks</h3>
          <div class="practice-item">
            <h4>useState</h4>
            <ul>
              <li>Use múltiplos useState para estados independentes</li>
              <li>Agrupe estados relacionados em um objeto</li>
              <li>
                Use função de atualização quando o novo estado depende do
                anterior
              </li>
            </ul>
          </div>
          <div class="practice-item">
            <h4>useEffect</h4>
            <ul>
              <li>Sempre inclua todas as dependências no array</li>
              <li>Use funções de cleanup para evitar memory leaks</li>
              <li>Separe efeitos não relacionados em diferentes useEffects</li>
            </ul>
          </div>
          <div class="practice-item">
            <h4>useReducer</h4>
            <ul>
              <li>Use para lógica de estado complexa</li>
              <li>Mantenha as ações bem definidas</li>
              <li>O reducer deve ser uma função pura</li>
            </ul>
          </div>
        </div>

        <h3>Regras dos Hooks</h3>
        <ul>
          <li>
            <strong>Só chame Hooks no nível mais alto</strong> - Não em loops,
            condições ou funções aninhadas
          </li>
          <li>
            <strong>Só chame Hooks de componentes React</strong> - Ou de custom
            hooks
          </li>
          <li>
            <strong>Siga a ordem dos Hooks</strong> - Sempre na mesma ordem a
            cada renderização
          </li>
          <li>
            <strong>Prefira Hooks personalizados</strong> - Para reutilizar
            lógica de estado entre componentes
          </li>
        </ul>

        <div class="hook-comparison">
          <h3>Quando usar cada Hook?</h3>
          <table>
            <tr>
              <th>Situação</th>
              <th>Hook Recomendado</th>
              <th>Motivo</th>
            </tr>
            <tr>
              <td>Estado simples (contador, toggle)</td>
              <td>useState</td>
              <td>Simplicidade e legibilidade</td>
            </tr>
            <tr>
              <td>Estado complexo (formulários múltiplos)</td>
              <td>useReducer</td>
              <td>Centraliza a lógica de atualização</td>
            </tr>
            <tr>
              <td>Efeitos colaterais (API, timers)</td>
              <td>useEffect</td>
              <td>Gerencia ciclo de vida</td>
            </tr>
            <tr>
              <td>Acesso direto ao DOM</td>
              <td>useRef</td>
              <td>Referência direta sem re-renderizar</td>
            </tr>
          </table>
        </div>
      </section>

      <!-- SEÇÃO 8: INSTALAÇÃO -->
      <section id="instalacao" class="main-section">
        <h2>Instalação e Configuração Inicial</h2>
        <p>Para começar a desenvolver nosso jogo, você vai precisar:</p>

        <h3>Ferramentas básicas</h3>
        <ul>
          <li><strong>Node.js</strong> (versão 16 ou superior - inclui npm)</li>
          <li><strong>Editor de código</strong> (VS Code recomendado)</li>
          <li><strong>Git</strong> para controle de versão</li>
        </ul>

        <h3>Criando o projeto com Vite</h3>
        <p>
          Vamos usar o Vite para criar nosso projeto, pois é mais rápido e
          moderno que o create-react-app:
        </p>

        <p>
          Abra o terminal no diretório onde deseja criar o projeto e execute os
          comandos para criar o projeto com React + TypeScript
        </p>

        <div class="code-container">
          <pre>npm create vite@latest card-game -- --template react-ts</pre>
          <button class="copy-btn no-print">Copiar</button>
        </div>

        <div class="code-container">
          <pre>cd card-game</pre>
          <button class="copy-btn no-print">Copiar</button>
        </div>

        <div class="code-container">
          <pre>npm install framer-motion</pre>
          <button class="copy-btn no-print">Copiar</button>
        </div>

        <div class="code-container">
          <pre>npm run dev</pre>
          <button class="copy-btn no-print">Copiar</button>
        </div>

        <p>
          Após executar <code>npm run dev</code>, o terminal mostrará um
          endereço local (geralmente <code>http://localhost:5173</code>). Acesse
          este endereço para ver a página padrão do React.
        </p>
      </section>

      <section id="estrutura-inicial" class="main-section">
        <h2>Entendendo a Estrutura Inicial do Projeto</h2>
        <p>
          Após criar o projeto, você verá uma estrutura de pastas como esta:
        </p>

        <div class="code-container">
          <pre>
card-game/
├── public/
│   └── vite.svg
├── src/
│   ├── assets/
│   │   └── react.svg
│   ├── App.css
│   ├── App.tsx
│   ├── index.css
│   ├── main.tsx
├── index.html
├── package.json</pre
          >
          <button class="copy-btn no-print">Copiar</button>
        </div>

        <h3>Arquivos Principais e Suas Funções</h3>

        <div class="file-structure">
          <div class="file-item">
            <h4>index.html</h4>
            <p>
              <strong>Ponto de entrada HTML</strong> - O arquivo HTML principal
              onde nossa aplicação React será "montada". Contém um elemento
              <code>&lt;div id="root"&gt;</code> onde todo o React será
              renderizado.
            </p>
          </div>

          <div class="file-item">
            <h4>src/main.tsx</h4>
            <p>
              <strong>Ponto de entrada JavaScript/TypeScript</strong> - Este
              arquivo é o primeiro código TypeScript executado. Sua função é
              técnica: ele "planta" (monta) o componente <code>App</code> dentro
              do elemento HTML com id <code>root</code>.
            </p>
            <div class="code-container">
              <pre>
// src/main.tsx - Exemplo simplificado
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css' // Importa os estilos globais

ReactDOM.createRoot(document.getElementById('root')!).render(
  &lt;React.StrictMode&gt;
    &lt;App /&gt;
  &lt;/React.StrictMode&gt;
)</pre
              >
              <button class="copy-btn no-print">Copiar</button>
            </div>
          </div>

          <div class="file-item">
            <h4>src/App.tsx</h4>
            <p>
              <strong>Componente Raiz</strong> - Este é o componente principal
              que define a estrutura inicial da sua aplicação visível na tela.
              Todo o desenvolvimento inicial de componentes, rotas e lógica
              começa aqui.
            </p>
            <div class="code-container">
              <pre>
// src/App.tsx - Exemplo simplificado
import { useState } from 'react'
import './App.css' // Importa os estilos específicos do App

function App() {
  // A lógica do seu componente é escrita aqui
  return (
    // O JSX (o que é renderizado na tela) é definido aqui
    &lt;div className="App"&gt;
      &lt;h1&gt;Meu Jogo de Cartas&lt;/h1&gt;
      {/* Seus outros componentes serão inseridos aqui */}
    &lt;/div&gt;
  )
}

export default App</pre
              >
              <button class="copy-btn no-print">Copiar</button>
            </div>
          </div>

          <div class="file-item">
            <h4>src/App.css vs src/index.css</h4>
            <p><strong>Diferença entre os arquivos de estilo:</strong></p>
            <ul>
              <li>
                <strong>index.css</strong>: Estilos <strong>globais</strong> da
                aplicação (fontes padrão, reset de margens, cores de tema)
              </li>
              <li>
                <strong>App.css</strong>: Estilos específicos para o componente
                <code>App.tsx</code>
              </li>
            </ul>
          </div>
        </div>

        <div class="note">
          <p>
            <strong>Resumo Prático:</strong> O <code>main.tsx</code> é o
            "montador" técnico que coloca o React na página, enquanto o
            <code>App.tsx</code> é o "conteúdo" principal que você verá e
            modificará constantemente.
          </p>
        </div>
      </section>

      <!-- SEÇÃO 9: IMPLEMENTAÇÃO DO JOGO -->
      <section id="implementacao-jogo" class="main-section">
        <h2>Implementação do UNO Simplificado</h2>
        <p>
          Vamos criar uma versão super simplificada do UNO para aprender React
          de forma prática e divertida!
        </p>

        <div class="implementation-steps">
          <h3>Conceito do UNO Simplificado</h3>
          <ul>
            <li>
              <strong>Objetivo</strong>: Ser o primeiro jogador a ficar sem
              cartas na mão
            </li>
            <li><strong>Jogadores</strong>: 2 jogadores humanos</li>
            <li>
              <strong>Cartas</strong>: Apenas números (0-9) e 4 cores básicas
            </li>
            <li><strong>Vitória</strong>: Primeiro sem cartas vence!</li>
          </ul>
        </div>

        <div class="implementation-step">
          <h3>1. Estrutura de Dados - UNO Simplificado</h3>
          <p>
            Primeiro, definimos os tipos TypeScript para nosso jogo. Esta
            estrutura de dados é fundamental para garantir que nosso código seja
            type-safe e previsível.
          </p>

          <div class="code-container">
            <pre>
// types/gametypes.ts
export type Cor = 'vermelho' | 'azul' | 'verde' | 'amarelo';

export type ValorCarta = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';

export type Carta = {
  id: string;
  cor: Cor;
  valor: ValorCarta;
}

export type Jogador = {
  id: string;
  nome: string;
  mao: Carta[];
  isHumano: boolean;
}

export type EstadoJogo = {
  jogadores: Jogador[];
  monteCompra: Carta[];
  monteDescarte: Carta[];
  vez: number; // índice do jogador atual
  corAtual: Cor;
  vencedor: Jogador | null;
  estado: 'preparacao' | 'jogando' | 'finalizado';
}

// Baralho simplificado - apenas números
export const BARALHO_COMPLETO: Carta[] = [];

// Cores disponíveis
const cores: Cor[] = ['vermelho', 'azul', 'verde', 'amarelo'];

// Criar cartas numeradas (0-9) para cada cor
cores.forEach(cor => {
  // Uma carta 0 de cada cor
  BARALHO_COMPLETO.push({
    id: `${cor}-0`,
    cor,
    valor: '0'
  });

  // Duas cartas de 1-9 para cada cor
  for (let i = 1; i <= 9; i++) {
    BARALHO_COMPLETO.push(
      {
        id: `${cor}-${i}-1`,
        cor,
        valor: i.toString() as ValorCarta,
      },
      {
        id: `${cor}-${i}-2`,
        cor,
        valor: i.toString() as ValorCarta,
      }
    );
  }
});</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>
        </div>

        <div class="implementation-step">
          <h3>2. Componentes - UNO Simplificado</h3>
          <p>
            Agora criamos os componentes React que formarão nossa interface. O
            componente <code>CartaUno</code> é um exemplo perfeito de componente
            de apresentação - ele apenas exibe dados e notifica quando é
            clicado.
          </p>

          <h4>Componente Carta UNO</h4>
          <div class="code-container">
            <pre>
// components/CartaUno.tsx
import type { Carta } from '../types/gametypes';

interface CartaUnoProps {
  carta: Carta;
  onClick?: () => void;
  selecionada?: boolean;
  jogavel?: boolean;
  virada?: boolean;
}

export function CartaUno({ carta, onClick, selecionada = false, jogavel = true, virada = false }: CartaUnoProps) {
  if (virada) {
    return (
      &lt;div className="carta carta-virada"&gt;
        &lt;div className="carta-verso"&gt;
          &lt;div className="logo-uno"&gt;UNO&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }

  return (
    &lt;div
      className={`carta carta-${carta.cor} ${selecionada ? 'carta-selecionada' : ''} ${!jogavel ? 'carta-inativa' : ''}`}
      onClick={jogavel ? onClick : undefined}
    &gt;
      &lt;div className="carta-topo"&gt;
        &lt;span className="carta-valor-pequeno"&gt;{carta.valor}&lt;/span&gt;
      &lt;/div&gt;
      
      &lt;div className="carta-centro"&gt;
        &lt;span className="carta-valor-grande"&gt;{carta.valor}&lt;/span&gt;
      &lt;/div&gt;
      
      &lt;div className="carta-base"&gt;
        &lt;span className="carta-valor-pequeno"&gt;{carta.valor}&lt;/span&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>

          <h4>Componente Mesa UNO</h4>
          <div class="code-container">
            <pre>
// components/MesaUno.tsx
import type { Carta } from '../types/gametypes';
import { CartaUno } from './CartaUno';

interface MesaUnoProps {
  cartaTopo: Carta;
  corAtual: string;
  monteCompra: Carta[];
  onComprarCarta: () => void;
}

export function MesaUno({ cartaTopo, corAtual, monteCompra, onComprarCarta }: MesaUnoProps) {
  return (
    &lt;div className="mesa-uno"&gt;
      &lt;div className="area-monte"&gt;
        &lt;div className="monte-descarte"&gt;
          &lt;CartaUno carta={cartaTopo} jogavel={false} /&gt;
          &lt;div className="cor-atual"&gt;
            Cor atual: &lt;span className={`cor-${corAtual}`}&gt;{corAtual}&lt;/span&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div className="monte-compra" onClick={onComprarCarta}&gt;
          &lt;CartaUno carta={monteCompra[0]} virada={true} jogavel={true} /&gt;
          &lt;div className="texto-comprar"&gt;Comprar ({monteCompra.length})&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>
        </div>

        <div class="implementation-step">
          <h3>3. Lógica do Jogo UNO Simplificado</h3>
          <p>
            Aqui usamos o <strong>useReducer</strong> para gerenciar o estado
            complexo do nosso jogo. O reducer é uma função pura que recebe o
            estado atual e uma ação, e retorna um novo estado. Isso torna as
            transições de estado previsíveis e testáveis.
          </p>

          <h4>Reducer do UNO</h4>
          <div class="code-container">
            <pre>
// context/unoReducer.ts
import type { EstadoJogo, Carta, Jogador } from '../types/gametypes';
import { BARALHO_COMPLETO } from '../types/gametypes';

type AcaoUno =
  | { type: 'INICIAR_JOGO' }
  | { type: 'JOGAR_CARTA'; carta: Carta; jogadorIndex: number }
  | { type: 'COMPRAR_CARTA'; jogadorIndex: number };

export function unoReducer(state: EstadoJogo, action: AcaoUno): EstadoJogo {
  switch (action.type) {
    case 'INICIAR_JOGO':
      return iniciarJogo();
    
    case 'JOGAR_CARTA':
      return jogarCarta(state, action.carta, action.jogadorIndex);
    
    case 'COMPRAR_CARTA':
      return comprarCarta(state, action.jogadorIndex);
    
    default:
      return state;
  }
}

function iniciarJogo(): EstadoJogo {
  // Embaralhar baralho
  const baralhoEmbaralhado = [...BARALHO_COMPLETO].sort(() => Math.random() - 0.5);
  
  // Distribuir 7 cartas para cada jogador (2 jogadores humanos)
  const jogadores: Jogador[] = [
    {
      id: 'jogador-1',
      nome: 'Jogador 1',
      mao: baralhoEmbaralhado.splice(0, 7),
      isHumano: true
    },
    {
      id: 'jogador-2',
      nome: 'Jogador 2',
      mao: baralhoEmbaralhado.splice(0, 7),
      isHumano: true
    }
  ];

  // Primeira carta do descarte
  const cartaInicial = baralhoEmbaralhado.pop()!;

  return {
    jogadores,
    monteCompra: baralhoEmbaralhado,
    monteDescarte: [cartaInicial],
    vez: 0, // Jogador 1 começa
    corAtual: cartaInicial.cor,
    vencedor: null,
    estado: 'jogando'
  };
}

function jogarCarta(state: EstadoJogo, carta: Carta, jogadorIndex: number): EstadoJogo {
  if (jogadorIndex !== state.vez) return state;
  
  const jogador = state.jogadores[jogadorIndex];
  
  // Verificar se a carta é jogável
  if (!podeJogarCarta(carta, state.monteDescarte[0], state.corAtual)) {
    return state;
  }

  // Remover carta da mão do jogador
  const novaMao = jogador.mao.filter(c => c.id !== carta.id);
  const novosJogadores = [...state.jogadores];
  novosJogadores[jogadorIndex] = { ...jogador, mao: novaMao };

  // Adicionar carta ao descarte
  const novoDescarte = [carta, ...state.monteDescarte];

  // Verificar vitória
  if (novaMao.length === 0) {
    return {
      ...state,
      jogadores: novosJogadores,
      monteDescarte: novoDescarte,
      vencedor: jogador,
      estado: 'finalizado'
    };
  }

  // Passar para o próximo jogador
  const proximaVez = (state.vez + 1) % state.jogadores.length;

  return {
    ...state,
    jogadores: novosJogadores,
    monteDescarte: novoDescarte,
    vez: proximaVez,
    corAtual: carta.cor
  };
}

function comprarCarta(state: EstadoJogo, jogadorIndex: number): EstadoJogo {
  if (jogadorIndex !== state.vez) return state;
  
  const jogador = state.jogadores[jogadorIndex];
  
  // Verificar se há cartas no monte de compra
  if (state.monteCompra.length === 0) {
    // Se não há cartas, reembaralhar o descarte (exceto a carta do topo)
    const [cartaTopo, ...restoDescarte] = state.monteDescarte;
    const novoMonteCompra = [...restoDescarte].sort(() => Math.random() - 0.5);
    const novoDescarte = [cartaTopo];
    
    return {
      ...state,
      monteCompra: novoMonteCompra,
      monteDescarte: novoDescarte
    };
  }

  // Comprar uma carta
  const cartaComprada = state.monteCompra.pop()!;
  const novaMao = [...jogador.mao, cartaComprada];
  const novosJogadores = [...state.jogadores];
  novosJogadores[jogadorIndex] = { ...jogador, mao: novaMao };

  // Passar a vez automaticamente após comprar
  const proximaVez = (state.vez + 1) % state.jogadores.length;

  return {
    ...state,
    jogadores: novosJogadores,
    monteCompra: [...state.monteCompra],
    vez: proximaVez
  };
}

function podeJogarCarta(carta: Carta, cartaTopo: Carta, corAtual: string): boolean {
  // Mesma cor ou mesmo valor
  return carta.cor === corAtual || carta.valor === cartaTopo.valor;
}</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>
        </div>

        <div class="implementation-step">
          <h3>4. App Principal - UNO Simplificado</h3>
          <p>
            Finalmente, integramos todos os componentes no App principal. Aqui
            usamos o hook <code>useReducer</code> para gerenciar o estado do
            jogo e o <code>dispatch</code> para enviar ações que modificam esse
            estado.
          </p>

          <div class="code-container">
            <pre>
// App.tsx - UNO Simplificado para 2 jogadores
import { useReducer } from 'react';
import { unoReducer } from './context/unoReducer';
import { CartaUno } from './components/CartaUno';
import { MesaUno } from './components/MesaUno';
import './App.css';

function App() {
  const [state, dispatch] = useReducer(unoReducer, {
    jogadores: [],
    monteCompra: [],
    monteDescarte: [],
    vez: 0,
    corAtual: 'vermelho',
    vencedor: null,
    estado: 'preparacao'
  });

  // Iniciar jogo automaticamente
  if (state.estado === 'preparacao') {
    dispatch({ type: 'INICIAR_JOGO' });
  }

  const jogadorAtual = state.jogadores[state.vez];
  const cartaTopo = state.monteDescarte[0];

  const handleJogarCarta = (carta: any, jogadorIndex: number) => {
    if (jogadorIndex === state.vez) {
      dispatch({ type: 'JOGAR_CARTA', carta, jogadorIndex });
    }
  };

  const handleComprarCarta = (jogadorIndex: number) => {
    if (jogadorIndex === state.vez) {
      dispatch({ type: 'COMPRAR_CARTA', jogadorIndex });
    }
  };

  const podeJogarCarta = (carta: any) => {
    return carta.cor === state.corAtual || carta.valor === cartaTopo.valor;
  };

  if (state.vencedor) {
    return (
      &lt;div className="tela-vitoria"&gt;
        &lt;div className="vitoria-container"&gt;
          &lt;h1&gt;{state.vencedor.nome} Venceu!&lt;/h1&gt;
          &lt;p&gt;Parabéns!&lt;/p&gt;
          &lt;button 
            onClick={() => dispatch({ type: 'INICIAR_JOGO' })}
            className="btn-principal"
          &gt;
            Jogar Novamente
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }

  return (
    &lt;div className="app-uno"&gt;
      &lt;header className="header-uno"&gt;
        &lt;h1&gt;🎮 UNO Simplificado&lt;/h1&gt;
        &lt;div className="info-jogo"&gt;
          &lt;span&gt;Vez: &lt;strong&gt;{jogadorAtual?.nome}&lt;/strong&gt;&lt;/span&gt;
          &lt;span&gt;Cor atual: &lt;span className={`cor-${state.corAtual}`}&gt;{state.corAtual}&lt;/span&gt;&lt;/span&gt;
        &lt;/div&gt;
      &lt;/header&gt;

      &lt;div className="area-jogo-uno"&gt;
        {/* Jogador 2 */}
        &lt;div className={`jogador-area ${state.vez === 1 ? 'jogador-ativo' : ''}`}&gt;
          &lt;h2&gt;{state.jogadores[1]?.nome}&lt;/h2&gt;
          &lt;div className="mao-jogador"&gt;
            {state.jogadores[1]?.mao.map((carta) => (
              &lt;CartaUno
                key={carta.id}
                carta={carta}
                onClick={() => handleJogarCarta(carta, 1)}
                jogavel={podeJogarCarta(carta) && state.vez === 1}
              /&gt;
            ))}
          &lt;/div&gt;
          &lt;div className="contador-cartas"&gt;
            {state.jogadores[1]?.mao.length} cartas
          &lt;/div&gt;
          {state.vez === 1 && (
            &lt;button onClick={() => handleComprarCarta(1)} className="btn-comprar"&gt;
              Comprar Carta
            &lt;/button&gt;
          )}
        &lt;/div&gt;

        {/* Mesa Central */}
        &lt;div className="mesa-central"&gt;
          &lt;MesaUno
            cartaTopo={cartaTopo}
            corAtual={state.corAtual}
            monteCompra={state.monteCompra}
            onComprarCarta={() => handleComprarCarta(state.vez)}
          /&gt;
        &lt;/div&gt;

        {/* Jogador 1 */}
        &lt;div className={`jogador-area ${state.vez === 0 ? 'jogador-ativo' : ''}`}&gt;
          &lt;h2&gt;{state.jogadores[0]?.nome}&lt;/h2&gt;
          &lt;div className="mao-jogador"&gt;
            {state.jogadores[0]?.mao.map((carta) => (
              &lt;CartaUno
                key={carta.id}
                carta={carta}
                onClick={() => handleJogarCarta(carta, 0)}
                jogavel={podeJogarCarta(carta) && state.vez === 0}
              /&gt;
            ))}
          &lt;/div&gt;
          &lt;div className="contador-cartas"&gt;
            {state.jogadores[0]?.mao.length} cartas
          &lt;/div&gt;
          {state.vez === 0 && (
            &lt;button onClick={() => handleComprarCarta(0)} className="btn-comprar"&gt;
              Comprar Carta
            &lt;/button&gt;
          )}
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

export default App;</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>
        </div>

        <div class="implementation-step">
          <h3>5. Estilos - Design UNO Simplificado</h3>
          <p>
            Os estilos CSS são importantes para criar uma experiência visual
            agradável. Usamos CSS Grid e Flexbox para criar um layout responsivo
            que funciona bem em diferentes tamanhos de tela.
          </p>

          <div class="code-container">
            <pre>
/* App.css - UNO Simplificado */
:root {
  --vermelho: #e74c3c;
  --azul: #3498db;
  --verde: #2ecc71;
  --amarelo: #f1c40f;
  --preto: #2c3e50;
  --branco: #ecf0f1;
}

* {
  margin: 0 auto;
  padding: 0;
  box-sizing: border-box;
}

body {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  min-height: 100vh;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  color: white;
}

.app-uno {
  max-width: 1000px;
  margin: 0 auto;
  padding: 20px;
  min-height: 100vh;
}

/* Header */
.header-uno {
  text-align: center;
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(255,255,255,0.1);
  border-radius: 15px;
}

.header-uno h1 {
  font-size: 2.5em;
  margin-bottom: 10px;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
}

.info-jogo {
  display: flex;
  justify-content: center;
  gap: 30px;
  font-size: 1.2em;
}

/* Área do Jogo */
.area-jogo-uno {
  display: flex;
  flex-direction: column;
  gap: 20px;
  flex: 1;
}

/* Jogadores */
.jogador-area {
  text-align: center;
  padding: 15px;
  background: rgba(255,255,255,0.1);
  border-radius: 15px;
  transition: all 0.3s ease;
}

.jogador-ativo {
  background: rgba(255,255,255,0.2);
  border: 2px solid rgba(255,255,255,0.3);
}

.jogador-area h2 {
  margin-bottom: 15px;
  font-size: 1.5em;
}

.mao-jogador {
  display: flex;
  justify-content: center;
  gap: 8px;
  flex-wrap: wrap;
  margin-bottom: 10px;
}

.contador-cartas {
  font-weight: bold;
  font-size: 1.1em;
  margin-bottom: 10px;
}

/* Mesa Central */
.mesa-central {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 150px;
}

.mesa-uno {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 15px;
}

.area-monte {
  display: flex;
  gap: 20px;
  align-items: center;
}

.monte-descarte, .monte-compra {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.cor-atual {
  font-weight: bold;
  font-size: 1.1em;
}

.cor-vermelho { color: var(--vermelho); }
.cor-azul { color: var(--azul); }
.cor-verde { color: var(--verde); }
.cor-amarelo { color: var(--amarelo); }

.texto-comprar {
  font-weight: bold;
  cursor: pointer;
}

/* Cartas */
.carta {
  width: 70px;
  height: 100px;
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  padding: 6px;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  position: relative;
  overflow: hidden;
}

.carta::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255,255,255,0.1);
  border-radius: 6px;
}

.carta-virada {
  background: linear-gradient(45deg, #e74c3c, #3498db);
}

.carta-verso {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, #e74c3c, #3498db, #2ecc71, #f1c40f);
  border-radius: 6px;
}

.logo-uno {
  font-size: 1.5em;
  font-weight: bold;
  color: white;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}

/* Cores das cartas */
.carta-vermelho { background: var(--vermelho); color: white; }
.carta-azul { background: var(--azul); color: white; }
.carta-verde { background: var(--verde); color: white; }
.carta-amarelo { background: var(--amarelo); color: #2c3e50; }

.carta-topo, .carta-base {
  display: flex;
  justify-content: flex-start;
  font-weight: bold;
  font-size: 0.9em;
}

.carta-base {
  justify-content: flex-end;
}

.carta-centro {
  display: flex;
  justify-content: center;
  align-items: center;
  flex: 1;
  font-size: 1.8em;
  font-weight: bold;
}

.carta-selecionada {
  transform: translateY(-10px);
  box-shadow: 0 8px 16px rgba(0,0,0,0.3);
}

.carta-inativa {
  opacity: 0.6;
  cursor: not-allowed;
}

/* Botões */
.btn-comprar, .btn-principal {
  background: linear-gradient(135deg, #667eea, #764ba2);
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 25px;
  font-size: 1em;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 4px 15px rgba(0,0,0,0.2);
}

.btn-comprar:hover, .btn-principal:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(0,0,0,0.3);
}

/* Tela de Vitória */
.tela-vitoria {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

.vitoria-container {
  text-align: center;
  max-width: 500px;
  padding: 40px;
  background: rgba(255,255,255,0.1);
  backdrop-filter: blur(10px);
  border-radius: 20px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.1);
}

.tela-vitoria h1 {
  font-size: 3em;
  margin-bottom: 20px;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
}
</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>
        </div>

        <div class="implementation-step">
          <h3>6. Animações com Framer Motion</h3>
          <p>
            Vamos adicionar animações suaves e interativas às cartas do UNO
            usando Framer Motion. Estas animações vão tornar o jogo mais
            dinâmico e divertido, com transições fluidas quando as cartas se
            movem, são compradas ou jogadas.
          </p>

          <h4>Instalação do Framer Motion</h4>
          <div class="code-container">
            <pre>
# Instale o Framer Motion no seu projeto
npm install framer-motion</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>

          <h4>Componente CartaUno com Animações</h4>
          <div class="code-container">
            <pre>
// components/CartaUno.tsx - ATUALIZADO COM FRAMER MOTION
import type { Carta } from '../types/gametypes';
import { motion } from 'framer-motion'; // Nova importação

interface CartaUnoProps {
  carta: Carta;
  onClick?: () => void;
  selecionada?: boolean;
  jogavel?: boolean;
  virada?: boolean;
}

export function CartaUno({ carta, onClick, selecionada = false, jogavel = true, virada = false }: CartaUnoProps) {
  if (virada) {
    return (
      &lt;motion.div 
        className="carta carta-virada"
        initial={{ opacity: 0, scale: 0.8 }}
        animate={{ opacity: 1, scale: 1 }}
        transition={{ duration: 0.3 }}
      &gt;
        &lt;div className="carta-verso"&gt;
          &lt;div className="logo-uno"&gt;UNO&lt;/div&gt;
        &lt;/div&gt;
      &lt;/motion.div&gt;
    );
  }

  return (
    &lt;motion.div
      className={`carta carta-${carta.cor} ${selecionada ? 'carta-selecionada' : ''} ${!jogavel ? 'carta-inativa' : ''}`}
      onClick={jogavel ? onClick : undefined}
      // Animações básicas do Framer Motion
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      whileHover={{ 
        scale: 1.05, 
        y: -5,
        transition: { duration: 0.2 }
      }}
      whileTap={{ scale: 0.95 }}
      transition={{ 
        type: "spring", 
        stiffness: 300, 
        damping: 20 
      }}
    &gt;
      &lt;div className="carta-topo"&gt;
        &lt;span className="carta-valor-pequeno"&gt;{carta.valor}&lt;/span&gt;
      &lt;/div&gt;
      
      &lt;div className="carta-centro"&gt;
        &lt;span className="carta-valor-grande"&gt;{carta.valor}&lt;/span&gt;
      &lt;/div&gt;
      
      &lt;div className="carta-base"&gt;
        &lt;span className="carta-valor-pequeno"&gt;{carta.valor}&lt;/span&gt;
      &lt;/div&gt;
    &lt;/motion.div&gt;
  );
}</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>

          <h4>MesaUno com Animações</h4>
          <div class="code-container">
            <pre>
// components/MesaUno.tsx - ATUALIZADO COM FRAMER MOTION
import type { Carta } from '../types/gametypes';
import { CartaUno } from './CartaUno';
import { motion } from 'framer-motion'; // Nova importação

interface MesaUnoProps {
  cartaTopo: Carta;
  corAtual: string;
  monteCompra: Carta[];
  onComprarCarta: () => void;
}

export function MesaUno({ cartaTopo, corAtual, monteCompra, onComprarCarta }: MesaUnoProps) {
  return (
    &lt;div className="mesa-uno"&gt;
      &lt;div className="area-monte"&gt;
        &lt;div className="monte-descarte"&gt;
          &lt;motion.div
            key={cartaTopo.id} // Importante: key única para animação
            initial={{ scale: 0.8, rotate: -10 }}
            animate={{ scale: 1, rotate: 0 }}
            transition={{ type: "spring", stiffness: 200 }}
          &gt;
            &lt;CartaUno carta={cartaTopo} jogavel={false} /&gt;
          &lt;/motion.div&gt;
          &lt;div className="cor-atual"&gt;
            Cor atual: &lt;span className={`cor-${corAtual}`}&gt;{corAtual}&lt;/span&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;motion.div 
          className="monte-compra" 
          onClick={onComprarCarta}
          whileHover={{ scale: 1.05 }}
          whileTap={{ scale: 0.95 }}
        &gt;
          &lt;CartaUno carta={monteCompra[0]} virada={true} jogavel={true} /&gt;
          &lt;div className="texto-comprar"&gt;Comprar ({monteCompra.length})&lt;/div&gt;
        &lt;/motion.div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>

          <h4>App Principal com Animações de Vitória</h4>
          <div class="code-container">
            <pre>
// App.tsx - ATUALIZADO COM ANIMAÇÕES DE VITÓRIA
import { useReducer } from 'react';
import { motion, AnimatePresence } from 'framer-motion'; // Novas importações
import { unoReducer } from './context/unoReducer';
import { CartaUno } from './components/CartaUno';
import { MesaUno } from './components/MesaUno';
import './App.css';

function App() {
  const [state, dispatch] = useReducer(unoReducer, {
    jogadores: [],
    monteCompra: [],
    monteDescarte: [],
    vez: 0,
    corAtual: 'vermelho',
    vencedor: null,
    estado: 'preparacao'
  });

  // ... resto do código anterior ...

  if (state.vencedor) {
    return (
      &lt;motion.div 
        className="tela-vitoria"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ duration: 0.5 }}
      &gt;
        &lt;motion.div 
          className="vitoria-container"
          initial={{ scale: 0.8, y: 50 }}
          animate={{ scale: 1, y: 0 }}
          transition={{ type: "spring", stiffness: 200 }}
        &gt;
          &lt;motion.h1
            initial={{ scale: 0 }}
            animate={{ scale: 1 }}
            transition={{ delay: 0.2, type: "spring", stiffness: 300 }}
          &gt;
            🎉 {state.vencedor.nome} Venceu!
          &lt;/motion.h1&gt;
          &lt;motion.p
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.4 }}
          &gt;
            Parabéns! 🃏
          &lt;/motion.p&gt;
          &lt;motion.button 
            onClick={() => dispatch({ type: 'INICIAR_JOGO' })}
            className="btn-principal"
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
          &gt;
            🔄 Jogar Novamente
          &lt;/motion.button&gt;
        &lt;/motion.div&gt;
      &lt;/motion.div&gt;
    );
  }

  // ... resto do return anterior ...
}</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>

          <div class="animation-tips">
            <h4>💡 Dicas Importantes:</h4>
            <ul>
              <li>
                As animações são <strong>leves e não interferem</strong> na
                lógica do jogo
              </li>
              <li>
                O <code>motion.div</code> funciona exatamente como uma
                <code>div</code> normal, mas com funcões de animação
              </li>
              <li>
                Use <code>key</code> única nas cartas para garantir que as
                animações funcionem corretamente
              </li>
              <li>
                As transições <code>spring</code> criam movimentos mais naturais
                e orgânicos
              </li>
            </ul>
          </div>
        </div>

        <div class="implementation-complete">
          <h3>UNO Simplificado Concluído!</h3>

          <div class="success-checklist">
            <h4>O Que Criamos:</h4>
            <ul>
              <li>
                <strong>Jogo UNO Super Simplificado</strong> - Apenas cartas
                numéricas (0-9)
              </li>
              <li>
                <strong>2 Jogadores Humanos</strong> - Interface simples e
                intuitiva
              </li>
              <li>
                <strong>4 Cores Básicas</strong> - Vermelho, Azul, Verde,
                Amarelo
              </li>
              <li>
                <strong>Regras Simples</strong> - Jogue cartas da mesma cor ou
                mesmo número
              </li>
              <li>
                <strong>Sistema de Turnos</strong> - Alternância automática
                entre jogadores
              </li>
              <li>
                <strong>Sistema de Vitória</strong> - Primeiro sem cartas vence
              </li>
            </ul>
          </div>
        </div>
      </section>

      <!-- CONCLUSÃO -->
      <section id="conclusao" class="main-section">
        <h2>Conclusão do Minicurso</h2>

        <div class="achievement-summary">
          <h3>O Que Aprendemos</h3>
          <div class="learned-grid">
            <div class="learned-item">
              <h4>Conceitos Fundamentais</h4>
              <ul>
                <li>TypeScript e tipagem estática</li>
                <li>Arquitetura baseada em componentes</li>
                <li>Props e comunicação entre componentes</li>
                <li>Estado local e global</li>
                <li>
                  Hooks do React (useState, useEffect, useReducer)
                </li>
              </ul>
            </div>

            <div class="learned-item">
              <h4>Implementação Prática</h4>
              <ul>
                <li>Modelagem de dados do jogo</li>
                <li>Sistema de cartas e recursos</li>
                <li>Lógica de turnos e ações</li>
                <li>Condições de vitória</li>
                <li>Interface de usuário intuitiva</li>
              </ul>
            </div>
          </div>
        </div>

        <div class="final-message">
          <h3>Parabéns pela Conclusão!</h3>
          <p>Você deu um grande passo no mundo do desenvolvimento React!</p>
          <p>Colocar aqui formulario de avaliacao</p>
        </div>
      </section>

      <button class="print-btn no-print" onclick="window.print()">
        <p class="no-print">Gerar PDF</p>
      </button>
    </main>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        // Selecionar todos os containers de código
        const codeContainers = document.querySelectorAll(".code-container");

        // Para cada container de código
        codeContainers.forEach((container) => {
          // Encontrar o botão de cópia dentro do container
          const copyBtn = container.querySelector(".copy-btn");
          // Encontrar o bloco de código dentro do container
          const codeBlock = container.querySelector("pre");

          // Adicionar evento de clique ao botão de cópia
          copyBtn.addEventListener("click", () => {
            // Obter o texto do bloco de código
            const code = codeBlock.textContent;

            // Copiar para a área de transferência
            navigator.clipboard
              .writeText(code)
              .then(() => {
                // Feedback visual
                copyBtn.textContent = "Copiado!";
                copyBtn.classList.add("copied");

                // Resetar após 2 segundos
                setTimeout(() => {
                  copyBtn.textContent = "Copiar";
                  copyBtn.classList.remove("copied");
                }, 2000);
              })
              .catch((err) => {
                console.error("Falha ao copiar: ", err);
                copyBtn.textContent = "Erro ao copiar";
              });
          });
        });

        // Navegação suave
        document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
          anchor.addEventListener("click", function (e) {
            e.preventDefault();

            const targetId = this.getAttribute("href");
            const targetElement = document.querySelector(targetId);

            if (targetElement) {
              targetElement.scrollIntoView({
                behavior: "smooth",
              });
            }
          });
        });
      });
    </script>
  </body>
</html>
