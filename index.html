<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
      Minicurso: Aprender React com Jogo de Cartas - Conceitos Fundamentais
    </title>
    <link rel="stylesheet" href="style.css" />

    <!-- Fontes -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap"
      rel="stylesheet"
    />
  </head>

  <body>
    <nav id="navbar" class="no-print">
      <img src="./logo.png" alt="logoInova" class="logo no-print" />
      <a href="#introducao" class="nav-link">Introdução</a>
      <a href="#typescript-conceito" class="nav-link">TypeScript</a>
      <a href="#react-conceito" class="nav-link">React</a>
      <a href="#componentes-conceito" class="nav-link">Componentes</a>
      <a href="#jsx-conceito" class="nav-link">JSX</a>
      <a href="#props-conceito" class="nav-link">Props</a>
      <a href="#estado-conceito" class="nav-link">Estado</a>
      <a href="#hooks-conceito" class="nav-link">Hooks</a>
      <a href="#instalacao" class="nav-link">Instalação</a>
      <a href="#implementacao-jogo" class="nav-link">Implementação</a>
      <a href="#conclusao" class="nav-link">Conclusão</a>
    </nav>

    <main id="main-doc">
      <h1>Minicurso: Aprender REACT fazendo um jogo de cartas</h1>

      <section id="introducao" class="main-section">
        <h2>Introdução: Aprendendo Conceitos</h2>
        <p>
          Bem-vindo ao minicurso onde você vai aprender React desenvolvendo um
          jogo de cartas! Neste curso, vamos abordar os conceitos fundamentais
          do React enquanto construímos um jogo onde os jogadores gerenciam
          recursos e constroem novas cartas a partir desses recursos.
        </p>

        <a href="https://www.canva.com/design/DAG2DaioYfc/X5qDzTJHuSmTA9QICsaneg/edit?utm_content=DAG2DaioYfc&utm_campaign=designshare&utm_medium=link2&utm_source=sharebutton">Link da Apresentação de Slides</a>

        <p>Vamos trabalhar com:</p>
        <ul>
          <li><strong>HTML</strong>: A estrutura básica da nossa aplicação</li>
          <li>
            <strong>CSS</strong>: Para estilizar nosso jogo e torná-lo
            visualmente atraente
          </li>
          <li>
            <strong>TypeScript</strong>: Para adicionar tipagem estática ao
            nosso código JavaScript
          </li>
          <li>
            <strong>React com TypeScript</strong>: A biblioteca principal que
            vamos aprender para desenvolvimento seguro
          </li>
          <li>
            <strong>useReducer</strong> para gerenciamento de estado complexo
          </li>
          <li>
            <strong>Componentes reutilizáveis</strong> para cartas e recursos
          </li>
        </ul>
      </section>

      <!-- SEÇÃO DOM: CONCEITOS FUNDAMENTAIS -->
      <section id="dom-conceito" class="main-section">
        <h2>DOM: A Ponte Entre JavaScript e a Página Web</h2>

        <div class="concept-explanation">
          <h3>O Que é o DOM?</h3>
          <p>
            O <strong>DOM (Document Object Model)</strong> é uma interface de
            programação que representa a estrutura de um documento HTML ou XML
            como uma árvore de objetos. Quando uma página web é carregada, o
            navegador cria uma representação em memória de todos os elementos da
            página, organizando-os em uma estrutura hierárquica que pode ser
            acessada e manipulada através de JavaScript.
          </p>

          <p>
            Pense no DOM como uma ponte entre o conteúdo estático da sua página
            (HTML) e a lógica dinâmica do seu código (JavaScript). Sem o DOM, o
            JavaScript não teria como interagir com os elementos da página,
            alterar conteúdos, responder a cliques ou modificar estilos.
          </p>

          <div class="dom-visual">
            <h4>O Processo de Renderização</h4>
            <p>
              Quando você acessa uma página web, o navegador passa por estas
              etapas:
            </p>
            <ol>
              <li>
                <strong>Parsing do HTML:</strong> O navegador lê o código HTML e
                identifica todos os elementos, atributos e conteúdo
              </li>
              <li>
                <strong>Criação do DOM:</strong> Constrói uma árvore de objetos
                representando a estrutura do documento
              </li>
              <li>
                <strong>Renderização:</strong> Usa o DOM para desenhar a página
                na tela
              </li>
              <li>
                <strong>Interação:</strong> Permite que o JavaScript modifique o
                DOM, atualizando automaticamente a visualização
              </li>
            </ol>
          </div>
        </div>

        <div class="dom-structure">
          <h3>A Estrutura Hierárquica do DOM</h3>
          <p>
            O DOM organiza os elementos em uma estrutura de árvore onde cada nó
            representa uma parte do documento. Esta hierarquia inclui relações
            de parentesco entre os elementos:
          </p>
          <ul>
            <li>
              <strong>Nó Raiz:</strong> O objeto <code>document</code> é a raiz
              de toda a árvore DOM
            </li>
            <li>
              <strong>Elementos Pais:</strong> Elementos que contêm outros
              elementos
            </li>
            <li>
              <strong>Elementos Filhos:</strong> Elementos contidos dentro de
              outros elementos
            </li>
            <li>
              <strong>Elementos Irmãos:</strong> Elementos que compartilham o
              mesmo elemento pai
            </li>
          </ul>

          <div class="code-example">
            <h4>Exemplo Prático de Estrutura HTML</h4>
            <p>Considere este código HTML simples:</p>
            <div class="code-container">
              <pre>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Minha Página&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;header&gt;
        &lt;h1&gt;Meu Site&lt;/h1&gt;
        &lt;nav&gt;
            &lt;ul&gt;
                &lt;li&gt;Home&lt;/li&gt;
                &lt;li&gt;Sobre&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/nav&gt;
    &lt;/header&gt;
    &lt;main&gt;
        &lt;p&gt;Conteúdo principal da página&lt;/p&gt;
        &lt;button id="botao-acao"&gt;Clique aqui&lt;/button&gt;
    &lt;/main&gt;
&lt;/body&gt;
&lt;/html&gt;</pre
              >
              <button class="copy-btn no-print">Copiar</button>
            </div>
          </div>

          <div class="dom-tree">
            <h4>Representação da Estrutura DOM</h4>
            <p>
              O navegador transforma o HTML acima na seguinte estrutura de
              árvore:
            </p>
            <div class="tree-diagram">
              <div class="tree-level">
                <strong>document</strong> (objeto raiz)
              </div>
              <div class="tree-level">
                ├── <strong>html</strong> (elemento raiz do documento)
              </div>
              <div class="tree-level">
                │ ├── <strong>head</strong> (contém metadados)
              </div>
              <div class="tree-level">
                │ │ └── <strong>title</strong> (título da página)
              </div>
              <div class="tree-level">
                │ └── <strong>body</strong> (contém o conteúdo visível)
              </div>
              <div class="tree-level">
                │ ├── <strong>header</strong> (cabeçalho da página)
              </div>
              <div class="tree-level">
                │ │ ├── <strong>h1</strong> (título principal)
              </div>
              <div class="tree-level">
                │ │ └── <strong>nav</strong> (menu de navegação)
              </div>
              <div class="tree-level">
                │ │ └── <strong>ul</strong> (lista não ordenada)
              </div>
              <div class="tree-level">
                │ │ ├── <strong>li</strong> (item da lista)
              </div>
              <div class="tree-level">
                │ │ └── <strong>li</strong> (item da lista)
              </div>
              <div class="tree-level">
                │ └── <strong>main</strong> (conteúdo principal)
              </div>
              <div class="tree-level">│ ├── <strong>p</strong> (parágrafo)</div>
              <div class="tree-level">
                │ └── <strong>button</strong> (botão com id "botao-acao")
              </div>
            </div>
          </div>
        </div>

        <div class="dom-manipulation">
          <h3>Manipulação do DOM com JavaScript</h3>
          <p>
            A verdadeira potência do DOM está na capacidade do JavaScript de
            selecionar, modificar, criar e remover elementos dinamicamente. Esta
            manipulação ocorre em tempo real, permitindo criar interfaces
            interativas e responsivas.
          </p>

          <h4>Seleção de Elementos</h4>
          <p>
            Antes de manipular qualquer elemento, precisamos primeiro
            selecioná-lo no DOM. Existem várias formas de fazer isso:
          </p>
          <div class="code-container">
            <pre>
// Seleção por ID - retorna um único elemento
const elementoUnico = document.getElementById('meu-id');

// Seleção por classe - retorna uma coleção HTML
const elementosClasse = document.getElementsByClassName('minha-classe');

// Seleção por tag - retorna uma coleção HTML
const todosParagrafos = document.getElementsByTagName('p');

// Seleção por seletor CSS - métodos modernos e flexíveis
const primeiroElemento = document.querySelector('.minha-classe');
const todosElementos = document.querySelectorAll('div.destaque');</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>

          <h4>Modificação de Elementos Existentes</h4>
          <p>
            Uma vez selecionado um elemento, podemos alterar suas propriedades,
            conteúdo e aparência:
          </p>
          <div class="code-container">
            <pre>
// Modificar conteúdo textual
elemento.textContent = 'Novo conteúdo de texto';
elemento.innerHTML = 'Texto com &lt;strong&gt;formatação HTML&lt;/strong&gt;';

// Alterar atributos
elemento.setAttribute('data-info', 'valor-personalizado');
const valor = elemento.getAttribute('id');

// Modificar estilos diretamente
elemento.style.color = 'blue';
elemento.style.fontSize = '18px';
elemento.style.display = 'none'; // Esconder elemento

// Trabalhar com classes CSS
elemento.classList.add('nova-classe');
elemento.classList.remove('classe-antiga');
elemento.classList.toggle('classe-alternativa'); // Adiciona ou remove
elemento.classList.contains('minha-classe'); // Verifica se tem a classe</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>

          <h4>Criação e Remoção de Elementos</h4>
          <p>
            Podemos criar novos elementos dinamicamente e inseri-los no DOM, ou
            remover elementos existentes:
          </p>
          <div class="code-container">
            <pre>
// Criar um novo elemento
const novoElemento = document.createElement('div');
novoElemento.textContent = 'Sou um novo elemento criado dinamicamente';
novoElemento.className = 'destaque';

// Inserir no DOM
document.body.appendChild(novoElemento); // No final do body
elementoPai.insertBefore(novoElemento, elementoReferencia); // Antes de um elemento específico
elementoPai.prepend(novoElemento); // Como primeiro filho

// Clonar elementos existentes
const elementoClone = elementoExistente.cloneNode(true);

// Remover elementos
elementoParaRemover.remove(); // Método moderno
elementoPai.removeChild(elementoFilho); // Método tradicional

// Limpar todos os filhos de um elemento
elementoPai.innerHTML = ''; // Método simples
while (elementoPai.firstChild) { // Método mais performático
    elementoPai.removeChild(elementoPai.firstChild);
}</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>
        </div>

        <div class="dom-events">
          <h3>Eventos do DOM: Criando Interatividade</h3>
          <p>
            Eventos são ações ou ocorrências que acontecem no navegador, como
            cliques do mouse, pressionamento de teclas, ou carregamento da
            página. Através do sistema de eventos do DOM, podemos "escutar"
            essas ocorrências e executar código em resposta.
          </p>

          <h4>Tipos Comuns de Eventos</h4>
          <p>Os eventos podem ser categorizados em vários tipos:</p>
          <ul>
            <li>
              <strong>Eventos de Mouse:</strong> click, dblclick, mouseover,
              mouseout, mousemove
            </li>
            <li>
              <strong>Eventos de Teclado:</strong> keydown, keyup, keypress
            </li>
            <li>
              <strong>Eventos de Formulário:</strong> submit, change, input,
              focus, blur
            </li>
            <li><strong>Eventos de Janela:</strong> load, resize, scroll</li>
            <li>
              <strong>Eventos de Toque:</strong> touchstart, touchmove, touchend
              (para dispositivos móveis)
            </li>
          </ul>

          <h4>Manipulação de Eventos</h4>
          <p>
            Para responder a eventos, usamos o método
            <code>addEventListener</code>:
          </p>
          <div class="code-container">
            <pre>
// Sintaxe básica
elemento.addEventListener('tipo-do-evento', funçãoResposta);

// Exemplo: Clique em um botão
const botao = document.getElementById('meu-botao');
botao.addEventListener('click', function(evento) {
    console.log('Botão clicado!');
    console.log('Elemento clicado:', evento.target);
    console.log('Coordenadas do clique:', evento.clientX, evento.clientY);
});

// Exemplo: Tecla pressionada em um input
const campoInput = document.querySelector('input[type="text"]');
campoInput.addEventListener('keydown', function(evento) {
    if (evento.key === 'Enter') {
        console.log('Enter pressionado!');
        evento.preventDefault(); // Impede comportamento padrão
    }
});

// Exemplo: Formulário enviado
const formulario = document.getElementById('meu-formulario');
formulario.addEventListener('submit', function(evento) {
    evento.preventDefault(); // Impede envio padrão do formulário
    console.log('Formulário seria enviado, mas impedimos');
    // Aqui podemos validar dados ou enviar via AJAX
});

// Exemplo: Página carregada
window.addEventListener('load', function() {
    console.log('Página completamente carregada, incluindo imagens');
});

// Exemplo: Mouse sobre elemento
elemento.addEventListener('mouseover', function() {
    elemento.style.backgroundColor = 'lightyellow';
});
elemento.addEventListener('mouseout', function() {
    elemento.style.backgroundColor = '';
});</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>

          <h4>Delegação de Eventos</h4>
          <p>
            Para melhor performance, especialmente com muitos elementos, podemos
            usar delegação de eventos - adicionar um único listener em um
            elemento pai que captura eventos dos filhos:
          </p>
          <div class="code-container">
            <pre>
// Em vez de adicionar listeners a cada botão
document.getElementById('lista-botoes').addEventListener('click', function(evento) {
    if (evento.target.classList.contains('botao-item')) {
        console.log('Botão clicado:', evento.target.textContent);
    }
});</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>
        </div>

        <div class="dom-challenges">
          <h3>Desafios da Manipulação Direta do DOM</h3>
          <p>
            Embora poderoso, trabalhar diretamente com o DOM apresenta vários
            desafios que se tornam mais evidentes em aplicações complexas:
          </p>

          <h4>Gerenciamento de Estado e Sincronização</h4>
          <p>
            Em aplicações com múltiplos elementos interdependentes, manter a
            interface sincronizada com os dados subjacentes torna-se complexo.
            Cada mudança de estado pode exigir atualizações manuais em vários
            lugares do DOM, aumentando a chance de inconsistências.
          </p>

          <h4>Problemas de Performance</h4>
          <p>
            Operações frequentes no DOM são custosas em termos de performance.
            Cada modificação pode disparar recalculos de layout e repaint pelo
            navegador. Em aplicações com muitas atualizações, isso pode resultar
            em lentidão perceptível.
          </p>

          <h4>Complexidade de Manutenção</h4>
          <p>
            O código que manipula o DOM diretamente tende a se espalhar por toda
            a aplicação, tornando difícil entender o fluxo de dados e as
            dependências entre diferentes partes da interface. Isso dificulta a
            manutenção e a adição de novas funcionalidades.
          </p>

          <h4>Gestão de Eventos</h4>
          <p>
            Em interfaces complexas, gerenciar múltiplos event listeners e
            garantir que sejam devidamente removidos quando elementos são
            deletados pode levar a vazamentos de memória e comportamentos
            inesperados.
          </p>
        </div>

        <div class="react-solution-intro">
          <h3>Como o React Simplifica o Trabalho com o DOM</h3>
          <p>
            O React aborda esses desafios através do conceito de
            <strong>DOM Virtual</strong>. Em vez de manipular o DOM diretamente,
            você descreve como sua interface deve aparecer em qualquer estado
            possível, e o React se encarrega de atualizar eficientemente o DOM
            real.
          </p>

          <h4>O Conceito de DOM Virtual</h4>
          <p>
            O DOM Virtual é uma representação em memória do DOM real. Quando o
            estado da sua aplicação muda, o React cria uma nova versão do DOM
            Virtual, compara com a versão anterior (processo chamado "diffing"),
            e determina a maneira mais eficiente de atualizar o DOM real.
          </p>

          <h4>Comparação: DOM Direto vs React</h4>
          <p>Vejamos a diferença na abordagem para um contador simples:</p>

          <div class="code-comparison">
            <div class="comparison-item">
              <h5>Manipulação Direta do DOM</h5>
              <div class="code-container">
                <pre>
// Precisa gerenciar manualmente todas as atualizações
let contador = 0;
const elementoContador = document.getElementById('contador');
const elementoStatus = document.getElementById('status');

function incrementar() {
    contador++;
    
    // Atualizações manuais necessárias
    elementoContador.textContent = contador;
    
    if (contador > 10) {
        elementoStatus.textContent = 'Alto';
        elementoStatus.className = 'status-alto';
    } else {
        elementoStatus.textContent = 'Normal';
        elementoStatus.className = 'status-normal';
    }
    
    // Mais elementos poderiam precisar de atualização...
}</pre
                >
                <button class="copy-btn no-print">Copiar</button>
              </div>
            </div>

            <div class="comparison-item">
              <h5>Com React</h5>
              <div class="code-container">
                <pre>
// Apenas declara o estado - React cuida das atualizações
function Contador() {
    const [contador, setContador] = useState(0);
    
    function incrementar() {
        setContador(contador + 1);
    }
    
    return (
        &lt;div&gt;
            &lt;span&gt;{contador}&lt;/span&gt;
            &lt;div className={contador > 10 ? 'status-alto' : 'status-normal'}&gt;
                {contador > 10 ? 'Alto' : 'Normal'}
            &lt;/div&gt;
            &lt;button onClick={incrementar}&gt;Incrementar&lt;/button&gt;
        &lt;/div&gt;
    );
}</pre
                >
                <button class="copy-btn no-print">Copiar</button>
              </div>
            </div>
          </div>

          <p>
            Com React, você se preocupa apenas em descrever como a interface
            deve ser baseada no estado atual. O React automaticamente determina
            quais partes do DOM precisam ser atualizadas e executa essas
            atualizações da forma mais eficiente possível.
          </p>
        </div>
      </section>

      <!-- SEÇÃO 1: TYPESCRIPT -->
      <section id="typescript-conceito" class="main-section">
        <h2>TypeScript: JavaScript com Tipagem</h2>

        <h3>O que é TypeScript?</h3>
        <p>
          TypeScript é um <strong>superset</strong> do JavaScript que adiciona
          <strong>tipagem estática</strong>. Isso significa que podemos definir
          tipos para nossas variáveis, funções e objetos, permitindo que erros
          sejam detectados durante o desenvolvimento, antes mesmo de executar o
          código.
        </p>

        <h3>Benefícios do TypeScript</h3>
        <ul>
          <li>
            <strong>Detecção de Erros Antecipada</strong>: Encontra bugs durante
            a escrita do código
          </li>
          <li>
            <strong>Autocomplete Inteligente</strong>: Editores sugerem
            propriedades e métodos corretos
          </li>
          <li>
            <strong>Documentação Automática</strong>: Os tipos servem como
            documentação viva
          </li>
          <li>
            <strong>Refatoração Segura</strong>: Mudanças no código são mais
            seguras e previsíveis
          </li>
        </ul>

        <h3>Exemplo Prático de TypeScript</h3>
        <div class="code-container">
          <pre>
// Tipos básicos
let nome: string = "João";
let idade: number = 25;
let ativo: boolean = true;
let numeros: number[] = [1, 2, 3];
let qualquer: any = "pode ser qualquer coisa";

// Interface para definir a forma de um objeto
interface Usuario {
    id: number;
    nome: string;
    email: string;
    ativo?: boolean; // Propriedade opcional
}

// Usando a interface
const usuario: Usuario = {
    id: 1,
    nome: "Maria",
    email: "maria@email.com"
    // ativo é opcional, então não precisa ser definido
};

// Função com tipos
function cumprimentar(usuario: Usuario): string {
    return `Olá, ${usuario.nome}!`;
}

// TypeScript previne erros:
// usuario.idade = 30; // ERRO: Propriedade 'idade' não existe no tipo 'Usuario'
// cumprimentar("texto"); // ERRO: Argumento do tipo string não é atribuível</pre
          >
          <button class="copy-btn no-print">Copiar</button>
        </div>
      </section>

      <!-- SEÇÃO 2: REACT -->
      <section id="react-conceito" class="main-section">
        <h2>React: A Biblioteca para Interfaces</h2>

        <h3>O que é React?</h3>
        <p>
          React é uma <strong>biblioteca JavaScript</strong> para construir
          interfaces de usuário. Sua principal característica é o conceito de
          <strong>componentes</strong> - pedaços de código reutilizáveis que
          representam partes da interface.
        </p>

        <h3>Princípios Fundamentais do React</h3>
        <ul>
          <li>
            <strong>Componentes</strong>: Divide o sistema em partes
            independentes e reutilizáveis
          </li>
          <li>
            <strong>Props</strong>: Passe dados para os componentes (entradas)
          </li>
          <li>
            <strong>Estado</strong>: Gerencia de dados que mudam com o tempo
          </li>
          <li>
            <strong>Renderização Declarativa</strong>: Descreve O QUE o sistema
            deve fazer e não COMO fazer
          </li>
        </ul>

        <h3>Declarativo vs Imperativo</h3>

        <div class="code-container">
          <pre>
// ABORDAGEM IMPERATIVA (Vanilla JavaScript)
// "COMO fazer" - passo a passo manual
function atualizarContadorImperativo() {
    const elemento = document.getElementById('contador');
    const valorAtual = parseInt(elemento.textContent);
    const novoValor = valorAtual + 1;
    elemento.textContent = novoValor.toString();
    
    if (novoValor > 5) {
        elemento.classList.add('destaque');
    } else {
        elemento.classList.remove('destaque');
    }
}

// ABORDAGEM DECLARATIVA (React)
// "O QUE queremos" - resultado desejado
function ContadorDeclarativo() {
    const [valor, setValor] = useState(0);
    
    const incrementar = () => {
        setValor(valor + 1);
    };
    
    return (
        &lt;div className={valor > 5 ? 'destaque' : ''}&gt;
            &lt;span&gt;{valor}&lt;/span&gt;
            &lt;button onClick={incrementar}&gt;Incrementar&lt;/button&gt;
        &lt;/div&gt;
    );
}</pre
          >
          <button class="copy-btn no-print">Copiar</button>
        </div>

        <h3>Exemplo: Componente Básico</h3>
        <div class="code-container">
          <pre>
// Componente React mais simples possível
function Saudacao() {
    return &lt;h1&gt;Olá, Mundo!&lt;/h1&gt;;
}

// Componente com lógica simples
function Relogio() {
    const [hora, setHora] = useState(new Date());
    
    useEffect(() => {
        const timer = setInterval(() => {
            setHora(new Date());
        }, 1000);
        
        return () => clearInterval(timer);
    }, []);
    
    return (
        &lt;div&gt;
            &lt;h2&gt;Hora atual:&lt;/h2&gt;
            &lt;p&gt;{hora.toLocaleTimeString()}&lt;/p&gt;
        &lt;/div&gt;
    );
}</pre
          >
          <button class="copy-btn no-print">Copiar</button>
        </div>
      </section>

      <!-- SEÇÃO 3: COMPONENTES -->
      <section id="componentes-conceito" class="main-section">
        <h2>Componentes: Blocos de Construção do React</h2>

        <h3>O que são Componentes?</h3>
        <p>
          Componentes são <strong>funções JavaScript</strong> que retornam
          elementos de interface (JSX). Eles permitem dividir a UI em partes
          independentes, reutilizáveis e de responsabilidade única.
        </p>

        <h3>Exemplo: Componente Botão Reutilizável</h3>
        <div class="code-container">
          <pre>
// Componente de UI (Presentacional)
interface BotaoProps {
    children: React.ReactNode;
    onClick?: () => void;
    tipo?: 'primario' | 'secundario' | 'perigo';
    desabilitado?: boolean;
    className?: string;
}

function Botao({ 
    children, 
    onClick, 
    tipo = 'primario',
    desabilitado = false,
    className = ''
}: BotaoProps) {
    const classes = `botao botao-${tipo} ${desabilitado ? 'botao-desabilitado' : ''} ${className}`;
    
    return (
        &lt;button 
            className={classes.trim()}
            onClick={onClick}
            disabled={desabilitado}
        &gt;
            {children}
        &lt;/button&gt;
    );
}

// Uso do componente
function App() {
    const [contador, setContador] = useState(0);
    
    return (
        &lt;div&gt;
            &lt;Botao 
                tipo="primario"
                onClick={() => setContador(contador + 1)}
            &gt;
                Incrementar: {contador}
            &lt;/Botao&gt;
            
            &lt;Botao 
                tipo="secundario"
                onClick={() => setContador(0)}
            &gt;
                Resetar
            &lt;/Botao&gt;
            
            &lt;Botao 
                tipo="perigo"
                desabilitado={contador === 0}
                onClick={() => setContador(contador - 1)}
            &gt;
                Decrementar
            &lt;/Botao&gt;
        &lt;/div&gt;
    );
}</pre
          >
          <button class="copy-btn no-print">Copiar</button>
        </div>
      </section>

      <!-- SEÇÃO 4: JSX -->
      <section id="jsx-conceito" class="main-section">
        <h2>JSX: HTML no JavaScript</h2>

        <h3>O que é JSX?</h3>
        <p>
          JSX é uma <strong>extensão de sintaxe</strong> do JavaScript que
          permite escrever HTML dentro do código JavaScript. É como o React
          "descreve" como a interface deve ficar.
        </p>

        <h3>Regras do JSX</h3>
        <ul>
          <li><strong>className</strong> em vez de <code>class</code></li>
          <li>
            <strong>Tags devem ser fechadas</strong> (<code>&lt;img /&gt;</code
            >, <code>&lt;br /&gt;</code>)
          </li>
          <li>
            <strong>Um elemento pai</strong> por componente (ou usar
            <code>&lt;&gt;&lt;/&gt;</code> - Fragment)
          </li>
          <li><strong>JavaScript entre {}</strong> para expressões</li>
          <li><strong>style</strong> recebe um objeto em vez de string</li>
        </ul>

        <h3>Exemplos de JSX</h3>

        <div class="code-container">
          <pre>
// JSX Básico
function Saudacao({ nome, idade }) {
    return (
        &lt;div className="saudacao"&gt;
            &lt;h1&gt;Olá, {nome}!&lt;/h1&gt;
            &lt;p&gt;Você tem {idade} anos&lt;/p&gt;
        &lt;/div&gt;
    );
}

// JSX com Eventos
function ContadorInterativo() {
    const [valor, setValor] = useState(0);
    
    const handleClick = (incremento: number) => {
        setValor(valor + incremento);
    };
    
    return (
        &lt;div&gt;
            &lt;h3&gt;Contador: {valor}&lt;/h3&gt;
            &lt;button onClick={() => handleClick(1)}&gt;
                +1
            &lt;/button&gt;
            &lt;button onClick={() => handleClick(-1)}&gt;
                -1
            &lt;/button&gt;
            &lt;button onClick={() => setValor(0)}&gt;
                Reset
            &lt;/button&gt;
        &lt;/div&gt;
    );
}</pre
          >
          <button class="copy-btn no-print">Copiar</button>
        </div>
      </section>

      <!-- SEÇÃO 5: PROPS -->
      <section id="props-conceito" class="main-section">
        <h2>Props: Comunicação entre Componentes</h2>

        <h3>O que são Props?</h3>
        <p>
          Props (abreviação de <strong>properties</strong>) são o mecanismo do
          React para passar dados de um componente pai para um componente filho.
          São <strong>imutáveis</strong> - o componente filho não pode
          alterá-las.
        </p>

        <h3>Características das Props</h3>
        <ul>
          <li><strong>Unidirecionais</strong>: Só fluem de pai para filho</li>
          <li><strong>Imutáveis</strong>: Componente filho não pode alterar</li>
          <li>
            <strong>Tipáveis</strong>: Podemos definir tipos com TypeScript
          </li>
          <li><strong>Configuráveis</strong>: Podem ter valores padrão</li>
        </ul>

        <h3>Exemplo Detalhado: Props em Ação</h3>

        <div class="code-container">
          <pre>
// Definindo as props do componente
interface BotaoProps {
  texto: string;
  cor?: string; // opcional
  onClick: () => void;
}

// Componente usando as props
function Botao({ texto, cor = "azul", onClick }: BotaoProps) {
  return (
    &lt;button 
      style={{ backgroundColor: cor }}
      onClick={onClick}
    &gt;
      {texto}
    &lt;/button&gt;
  );
}

// Como usar o componente
function App() {
  const handleClick = () => {
    console.log("Botão clicado!");
  };

  return (
    &lt;div&gt;
      &lt;Botao 
        texto="Clique aqui" 
        onClick={handleClick} 
      /&gt;
      
      &lt;Botao 
        texto="Delete" 
        cor="vermelho" 
        onClick={handleClick} 
      /&gt;
    &lt;/div&gt;
  );
}</pre
          >
          <button class="copy-btn no-print">Copiar</button>
        </div>
      </section>

      <!-- SEÇÃO 6: ESTADO -->
      <section id="estado-conceito" class="main-section">
        <h2>Estado: Dados que Mudam com o Tempo</h2>

        <h3>O que é Estado?</h3>
        <p>
          Estado representa os <strong>dados que podem mudar</strong> durante a
          vida de um componente. Quando o estado muda, o React automaticamente
          <strong>re-renderiza</strong> o componente para refletir essas
          mudanças.
        </p>

        <h3>Exemplos de Estado</h3>
        <ul>
          <li>
            <strong>Dados dinâmicos</strong>: Contadores, formulários, filtros
            ativos
          </li>
          <li>
            <strong>Interações do usuário</strong>: Itens selecionados, opções
            ativas, menus abertos
          </li>
          <li>
            <strong>Dados de API</strong>: Listas de usuários, informações do
            servidor
          </li>
          <li>
            <strong>Estado da UI</strong>: Loading, erros, temas claro/escuro
          </li>
        </ul>

        <h3>useState: O Hook Básico de Estado</h3>

        <div class="code-container">
          <pre>
// ANTES (variável normal - NÃO FUNCIONA)
let contador = 0;
contador = 1; // A tela NÃO atualiza

// DEPOIS (estado - FUNCIONA)
const [contador, setContador] = useState(0);
setContador(1); // A tela atualiza AUTOMATICAMENTE</pre
          >
          <button class="copy-btn no-print">Copiar</button>
        </div>

        <h3>Estado Local vs Global</h3>

        <div class="state-types">
          <div class="state-type">
            <h4>Estado Local</h4>
            <p>
              <strong>Uso:</strong> Dados usados apenas por um componente<br />
              <strong>Exemplo:</strong> Input de formulário, menu
              aberto/fechado, loading local<br />
              <strong>Hook:</strong> <code>useState</code>
            </p>
          </div>

          <div class="state-type">
            <h4>Estado Global</h4>
            <p>
              <strong>Uso:</strong> Dados compartilhados entre vários
              componentes<br />
              <strong>Exemplo:</strong> Usuário logado, tema da aplicação,
              carrinho de compras<br />
              <strong>Soluções:</strong> Context API
            </p>
          </div>
        </div>
      </section>

      <!-- SEÇÃO 7: HOOKS -->
      <section id="hooks-conceito" class="main-section">
        <h2>Hooks: Funcionalidades do React</h2>

        <h3>O que são Hooks?</h3>
        <p>
          Hooks são <strong>funções especiais</strong> que permitem "conectar"
          funcionalidades do React a componentes funcionais. Eles sempre começam
          com <code>use</code> (useState, useEffect, etc.) e permitem usar
          estado e outras características do React sem escrever uma classe.
        </p>

        <h3>Hooks Principais</h3>

        <div class="hooks-grid">
          <div class="hook-item">
            <h4>useState</h4>
            <p>
              <strong>Função:</strong> Gerenciar estado local em componentes
              funcionais<br />
              <strong>Uso:</strong> Contadores, formulários, toggle states<br />
              <strong>Retorna:</strong> [valor, funçãoParaAtualizar]<br />
              <strong>Exemplo:</strong> const [count, setCount] = useState(0)
            </p>
            <div class="hook-details">
              <p>
                <strong>Quando usar:</strong> Para qualquer estado simples que
                precise ser atualizado e cause re-renderização do componente.
              </p>
            </div>
          </div>

          <div class="hook-item">
            <h4>useEffect</h4>
            <p>
              <strong>Função:</strong> Executar efeitos colaterais<br />
              <strong>Uso:</strong> API calls, subscriptions, timers<br />
              <strong>Substitui:</strong> componentDidMount, componentDidUpdate,
              componentWillUnmount<br />
              <strong>Exemplo:</strong> useEffect(() => { ... }, [dependencias])
            </p>
            <div class="hook-details">
              <p>
                <strong>Quando usar:</strong> Para operações que interagem com o
                mundo externo ou precisam sincronizar com mudanças de
                estado/props.
              </p>
            </div>
          </div>

          <div class="hook-item">
            <h4>useReducer</h4>
            <p>
              <strong>Função:</strong> Estado complexo com ações<br />
              <strong>Uso:</strong> Formulários complexos, estado com lógica
              elaborada<br />
              <strong>Padrão:</strong> (state, action) => newState<br />
              <strong>Exemplo:</strong> const [state, dispatch] =
              useReducer(reducer, initialState)
            </p>
            <div class="hook-details">
              <p>
                <strong>Quando usar:</strong> Quando o estado tem lógica
                complexa ou quando o próximo estado depende do anterior.
              </p>
            </div>
          </div>

          <div class="hook-item">
            <h4>useRef</h4>
            <p>
              <strong>Função:</strong> Acessar elementos DOM e persistir
              valores<br />
              <strong>Uso:</strong> Foco em inputs, medições, valores
              mutáveis<br />
              <strong>Característica:</strong> Não causa re-renderização<br />
              <strong>Exemplo:</strong> const inputRef = useRef(null)
            </p>
            <div class="hook-details">
              <p>
                <strong>Quando usar:</strong> Para acessar elementos DOM
                diretamente ou manter valores que não devem disparar
                re-renderizações.
              </p>
            </div>
          </div>
        </div>

        <h3>Explicação Detalhada: useEffect</h3>
        <p>
          O <code>useEffect</code> é usado para executar efeitos colaterais em
          componentes funcionais. Ele substitui <code>componentDidMount</code>,
          <code>componentDidUpdate</code> e
          <code>componentWillUnmount</code>
          dos componentes de classe.
        </p>

        <div class="useEffect-examples">
          <h4>Padrões Comuns do useEffect:</h4>
          <ul>
            <li>
              <strong>[] (array vazio):</strong> Executa apenas uma vez após a
              montagem do componente
            </li>
            <li>
              <strong>[var1, var2]:</strong> Executa sempre que alguma das
              dependências mudar
            </li>
            <li>
              <strong>Sem array:</strong> Executa após cada renderização (não
              recomendado)
            </li>
            <li>
              <strong>Função de cleanup:</strong> Retorna uma função para limpar
              recursos
            </li>
          </ul>
        </div>

        <h3>Exemplo: useEffect para Diferentes Cenários</h3>

        <div class="code-container">
          <pre>
import { useState, useEffect, useRef } from 'react';

// Exemplo 1: useEffect para API call (componentDidMount)
function ListaUsuarios() {
    const [usuarios, setUsuarios] = useState([]);
    const [carregando, setCarregando] = useState(true);
    const [erro, setErro] = useState(null);
    
    // Executa apenas uma vez quando o componente monta
    useEffect(() => {
        async function carregarUsuarios() {
            try {
                setCarregando(true);
                const resposta = await fetch('https://jsonplaceholder.typicode.com/users');
                const dados = await resposta.json();
                setUsuarios(dados);
            } catch (err) {
                setErro('Erro ao carregar usuários');
            } finally {
                setCarregando(false);
            }
        }
        
        carregarUsuarios();
    }, []); // Array de dependências vazio = executa apenas uma vez
    
    if (carregando) return &lt;div&gt;Carregando...&lt;/div&gt;;
    if (erro) return &lt;div&gt;{erro}&lt;/div&gt;;
    
    return (
        &lt;ul&gt;
            {usuarios.map(usuario => (
                &lt;li key={usuario.id}&gt;{usuario.name}&lt;/li&gt;
            ))}
        &lt;/ul&gt;
    );
}

// Exemplo 2: useEffect com dependências (componentDidUpdate)
function ContadorComHistorico() {
    const [contador, setContador] = useState(0);
    const [historico, setHistorico] = useState([]);
    
    // Executa sempre que 'contador' mudar
    useEffect(() => {
        setHistorico(prev => [...prev, contador]);
        console.log(`Contador atualizado para: ${contador}`);
    }, [contador]); // Dependência: executa quando 'contador' muda
    
    return (
        &lt;div&gt;
            &lt;h2&gt;Contador: {contador}&lt;/h2&gt;
            &lt;button onClick={() => setContador(c => c + 1)}&gt;
                Incrementar
            &lt;/button&gt;
            &lt;h3&gt;Histórico:&lt;/h3&gt;
            &lt;ul&gt;
                {historico.map((valor, index) => (
                    &lt;li key={index}&gt;{valor}&lt;/li&gt;
                ))}
            &lt;/ul&gt;
        &lt;/div&gt;
    );
}

// Exemplo 3: useEffect com cleanup (componentWillUnmount)
function RelogioComCleanup() {
    const [hora, setHora] = useState(new Date());
    
    useEffect(() => {
        const timerID = setInterval(() => {
            setHora(new Date());
        }, 1000);
        
        // Função de cleanup - executa quando o componente desmonta
        return () => {
            console.log('Limpando timer...');
            clearInterval(timerID);
        };
    }, []); // Array vazio = setup e cleanup uma vez
    
    return &lt;div&gt;Hora atual: {hora.toLocaleTimeString()}&lt;/div&gt;;
}

// Exemplo 4: useRef para acessar elementos DOM
function InputComFoco() {
    const inputRef = useRef(null);
    const [valor, setValor] = useState('');
    
    const focarInput = () => {
        // Acessa o elemento DOM diretamente
        inputRef.current.focus();
        inputRef.current.select();
    };
    
    return (
        &lt;div&gt;
            &lt;input
                ref={inputRef}
                value={valor}
                onChange={(e) => setValor(e.target.value)}
                placeholder="Digite algo..."
            /&gt;
            &lt;button onClick={focarInput}&gt;
                Focar no Input
            &lt;/button&gt;
        &lt;/div&gt;
    );
}

// Exemplo 5: useReducer para estado complexo
function reducer(state, action) {
    switch (action.type) {
        case 'incrementar':
            return { contador: state.contador + 1 };
        case 'decrementar':
            return { contador: state.contador - 1 };
        case 'resetar':
            return { contador: 0 };
        default:
            throw new Error(`Ação desconhecida: ${action.type}`);
    }
}

function ContadorReducer() {
    const [state, dispatch] = useReducer(reducer, { contador: 0 });
    
    return (
        &lt;div&gt;
            &lt;h2&gt;Contador: {state.contador}&lt;/h2&gt;
            &lt;button onClick={() => dispatch({ type: 'incrementar' })}&gt;
                +
            &lt;/button&gt;
            &lt;button onClick={() => dispatch({ type: 'decrementar' })}&gt;
                -
            &lt;/button&gt;
            &lt;button onClick={() => dispatch({ type: 'resetar' })}&gt;
                Reset
            &lt;/button&gt;
        &lt;/div&gt;
    );
}</pre
          >
          <button class="copy-btn no-print">Copiar</button>
        </div>

        <div class="best-practices">
          <h3>Boas Práticas com Hooks</h3>
          <div class="practice-item">
            <h4>useState</h4>
            <ul>
              <li>Use múltiplos useState para estados independentes</li>
              <li>Agrupe estados relacionados em um objeto</li>
              <li>
                Use função de atualização quando o novo estado depende do
                anterior
              </li>
            </ul>
          </div>
          <div class="practice-item">
            <h4>useEffect</h4>
            <ul>
              <li>Sempre inclua todas as dependências no array</li>
              <li>Use funções de cleanup para evitar memory leaks</li>
              <li>Separe efeitos não relacionados em diferentes useEffects</li>
            </ul>
          </div>
          <div class="practice-item">
            <h4>useReducer</h4>
            <ul>
              <li>Use para lógica de estado complexa</li>
              <li>Mantenha as ações bem definidas</li>
              <li>O reducer deve ser uma função pura</li>
            </ul>
          </div>
        </div>

        <h3>Regras dos Hooks</h3>
        <ul>
          <li>
            <strong>Só chame Hooks no nível mais alto</strong> - Não em loops,
            condições ou funções aninhadas
          </li>
          <li>
            <strong>Só chame Hooks de componentes React</strong> - Ou de custom
            hooks
          </li>
          <li>
            <strong>Siga a ordem dos Hooks</strong> - Sempre na mesma ordem a
            cada renderização
          </li>
          <li>
            <strong>Prefira Hooks personalizados</strong> - Para reutilizar
            lógica de estado entre componentes
          </li>
        </ul>

        <div class="hook-comparison">
          <h3>Quando usar cada Hook?</h3>
          <table>
            <tr>
              <th>Situação</th>
              <th>Hook Recomendado</th>
              <th>Motivo</th>
            </tr>
            <tr>
              <td>Estado simples (contador, toggle)</td>
              <td>useState</td>
              <td>Simplicidade e legibilidade</td>
            </tr>
            <tr>
              <td>Estado complexo (formulários múltiplos)</td>
              <td>useReducer</td>
              <td>Centraliza a lógica de atualização</td>
            </tr>
            <tr>
              <td>Efeitos colaterais (API, timers)</td>
              <td>useEffect</td>
              <td>Gerencia ciclo de vida</td>
            </tr>
            <tr>
              <td>Acesso direto ao DOM</td>
              <td>useRef</td>
              <td>Referência direta sem re-renderizar</td>
            </tr>
          </table>
        </div>
      </section>

      <!-- SEÇÃO 8: INSTALAÇÃO -->
      <section id="instalacao" class="main-section">
        <h2>Instalação e Configuração Inicial</h2>
        <p>Para começar a desenvolver nosso jogo, você vai precisar:</p>

        <h3>Ferramentas básicas</h3>
        <ul>
          <li><strong>Node.js</strong> (versão 16 ou superior - inclui npm)</li>
          <li><strong>Editor de código</strong> (VS Code recomendado)</li>
          <li><strong>Git</strong> para controle de versão</li>
        </ul>

        <h3>Criando o projeto com Vite</h3>
        <p>
          Vamos usar o Vite para criar nosso projeto, pois é mais rápido e
          moderno que o create-react-app:
        </p>

        <p>
          Abra o terminal no diretório onde deseja criar o projeto e execute os
          comandos para criar o projeto com React + TypeScript
        </p>

        <div class="code-container">
          <pre>npm create vite@latest card-game -- --template react-ts</pre>
          <button class="copy-btn no-print">Copiar</button>
        </div>

        <div class="code-container">
          <pre>cd card-game</pre>
          <button class="copy-btn no-print">Copiar</button>
        </div>

        <div class="code-container">
          <pre>npm install framer-motion</pre>
          <button class="copy-btn no-print">Copiar</button>
        </div>

        <div class="code-container">
          <pre>npm run dev</pre>
          <button class="copy-btn no-print">Copiar</button>
        </div>

        <p>
          Após executar <code>npm run dev</code>, o terminal mostrará um
          endereço local (geralmente <code>http://localhost:5173</code>). Acesse
          este endereço para ver a página padrão do React.
        </p>
      </section>

      <section id="estrutura-inicial" class="main-section">
        <h2>Entendendo a Estrutura Inicial do Projeto</h2>
        <p>
          Após criar o projeto, você verá uma estrutura de pastas como esta:
        </p>

        <div class="code-container">
          <pre>
card-game/
├── public/
│   └── vite.svg
├── src/
│   ├── assets/
│   │   └── react.svg
│   ├── App.css
│   ├── App.tsx
│   ├── index.css
│   ├── main.tsx
├── index.html
├── package.json</pre
          >
          <button class="copy-btn no-print">Copiar</button>
        </div>

        <h3>Arquivos Principais e Suas Funções</h3>

        <div class="file-structure">
          <div class="file-item">
            <h4>index.html</h4>
            <p>
              <strong>Ponto de entrada HTML</strong> - O arquivo HTML principal
              onde nossa aplicação React será "montada". Contém um elemento
              <code>&lt;div id="root"&gt;</code> onde todo o React será
              renderizado.
            </p>
          </div>

          <div class="file-item">
            <h4>src/main.tsx</h4>
            <p>
              <strong>Ponto de entrada JavaScript/TypeScript</strong> - Este
              arquivo é o primeiro código TypeScript executado. Sua função é
              técnica: ele "planta" (monta) o componente <code>App</code> dentro
              do elemento HTML com id <code>root</code>.
            </p>
            <div class="code-container">
              <pre>
// src/main.tsx - Exemplo simplificado
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css' // Importa os estilos globais

ReactDOM.createRoot(document.getElementById('root')!).render(
  &lt;React.StrictMode&gt;
    &lt;App /&gt;
  &lt;/React.StrictMode&gt;
)</pre
              >
              <button class="copy-btn no-print">Copiar</button>
            </div>
          </div>

          <div class="file-item">
            <h4>src/App.tsx</h4>
            <p>
              <strong>Componente Raiz</strong> - Este é o componente principal
              que define a estrutura inicial da sua aplicação visível na tela.
              Todo o desenvolvimento inicial de componentes, rotas e lógica
              começa aqui.
            </p>
            <div class="code-container">
              <pre>
// src/App.tsx - Exemplo simplificado
import { useState } from 'react'
import './App.css' // Importa os estilos específicos do App

function App() {
  // A lógica do seu componente é escrita aqui
  return (
    // O JSX (o que é renderizado na tela) é definido aqui
    &lt;div className="App"&gt;
      &lt;h1&gt;Meu Jogo de Cartas&lt;/h1&gt;
      {/* Seus outros componentes serão inseridos aqui */}
    &lt;/div&gt;
  )
}

export default App</pre
              >
              <button class="copy-btn no-print">Copiar</button>
            </div>
          </div>

          <div class="file-item">
            <h4>src/App.css vs src/index.css</h4>
            <p><strong>Diferença entre os arquivos de estilo:</strong></p>
            <ul>
              <li>
                <strong>index.css</strong>: Estilos <strong>globais</strong> da
                aplicação (fontes padrão, reset de margens, cores de tema)
              </li>
              <li>
                <strong>App.css</strong>: Estilos específicos para o componente
                <code>App.tsx</code>
              </li>
            </ul>
          </div>
        </div>

        <div class="note">
          <p>
            <strong>Resumo Prático:</strong> O <code>main.tsx</code> é o
            "montador" técnico que coloca o React na página, enquanto o
            <code>App.tsx</code> é o "conteúdo" principal que você verá e
            modificará constantemente.
          </p>
        </div>
      </section>

      <!-- SEÇÃO 9: IMPLEMENTAÇÃO DO JOGO - PASSO A PASSO -->
      <section id="implementacao-jogo" class="main-section">
        <h2>Implementação do UNO Simplificado - Passo a Passo</h2>
        <p>
          Vamos criar uma versão super simplificada do UNO para aprender React
          de forma prática e divertida! Vamos construir passo a passo.
        </p>

        <div class="implementation-steps">
          <h3>Conceito do UNO Simplificado</h3>
          <ul>
            <li>
              <strong>Objetivo</strong>: Ser o primeiro jogador a ficar sem
              cartas na mão
            </li>
            <li><strong>Jogadores</strong>: 2 jogadores humanos</li>
            <li>
              <strong>Cartas</strong>: Apenas números (0-9) e 4 cores básicas
            </li>
            <li><strong>Vitória</strong>: Primeiro sem cartas vence!</li>
          </ul>
        </div>

        <!-- PASSO 1: ESTRUTURA DO PROJETO -->
        <div class="implementation-step">
          <h3>Passo 1: Estrutura do Projeto</h3>
          <p>Primeiro, vamos criar a estrutura de pastas do nosso projeto:</p>

          <div class="file-structure">
            <pre>
src/
├── components/
│   ├── CartaUno.tsx
│   └── MesaUno.tsx
├── types/
│   └── gametypes.ts
├── context/
│   └── unoReducer.ts
├── App.tsx
└── App.css</pre
            >
          </div>
        </div>

        <!-- PASSO 2: TIPOS BÁSICOS -->
        <div class="implementation-step">
          <h3>Passo 2: Definindo os Tipos TypeScript</h3>
          <p>
            Crie o arquivo <code>types/gametypes.ts</code> com os tipos básicos:
          </p>

          <div class="code-container">
            <pre>
// types/gametypes.ts
export type Cor = 'vermelho' | 'azul' | 'verde' | 'amarelo';

export type ValorCarta = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';

export type Carta = {
  id: string;
  cor: Cor;
  valor: ValorCarta;
}

export type Jogador = {
  id: string;
  nome: string;
  mao: Carta[];
  isHumano: boolean;
}

export type EstadoJogo = {
  jogadores: Jogador[];
  monteCompra: Carta[];
  monteDescarte: Carta[];
  vez: number;
  corAtual: Cor;
  vencedor: Jogador | null;
  estado: 'preparacao' | 'jogando' | 'finalizado';
}</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>
        </div>

        <!-- PASSO 3: COMPONENTE CARTA -->
        <div class="implementation-step">
          <h3>Passo 3: Componente Carta Básico</h3>
          <p>
            Crie <code>components/CartaUno.tsx</code> - versão inicial simples:
          </p>

          <div class="code-container">
            <pre>
// components/CartaUno.tsx - VERSÃO INICIAL
import type { Carta } from '../types/gametypes';

interface CartaUnoProps {
  carta: Carta;
}

export function CartaUno({ carta }: CartaUnoProps) {
  return (
    &lt;div className={`carta carta-${carta.cor}`}&gt;
      &lt;div className="carta-topo"&gt;
        &lt;span className="carta-valor-pequeno"&gt;{carta.valor}&lt;/span&gt;
      &lt;/div&gt;
      
      &lt;div className="carta-centro"&gt;
        &lt;span className="carta-valor-grande"&gt;{carta.valor}&lt;/span&gt;
      &lt;/div&gt;
      
      &lt;div className="carta-base"&gt;
        &lt;span className="carta-valor-pequeno"&gt;{carta.valor}&lt;/span&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>
        </div>

        <!-- PASSO 4: APP INICIAL -->
        <div class="implementation-step">
          <h3>Passo 4: App Inicial - Testando o Componente Carta</h3>
          <p>Vamos criar um App básico para testar nosso componente:</p>

          <div class="code-container">
            <pre>
// App.tsx - VERSÃO INICIAL
import { CartaUno } from './components/CartaUno';
import './App.css';

function App() {
  // Carta de teste
  const cartaTeste = {
    id: 'teste-1',
    cor: 'vermelho' as const,
    valor: '5' as const,
  };

  return (
    &lt;div className="app-uno"&gt;
      &lt;h1&gt;🎮 UNO Simplificado - Teste&lt;/h1&gt;
      &lt;div className="area-teste"&gt;
        &lt;CartaUno carta={cartaTeste} /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

export default App;</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>
        </div>

        <!-- PASSO 5: ESTILOS BÁSICOS -->
        <div class="implementation-step">
          <h3>Passo 5: Estilos Básicos</h3>
          <p>Adicione estilos básicos em <code>App.css</code>:</p>

          <div class="code-container">
            <pre>
/* App.css - ESTILOS BÁSICOS */
:root {
  --vermelho: #e74c3c;
  --azul: #3498db;
  --verde: #2ecc71;
  --amarelo: #f1c40f;
  --preto: #2c3e50;
  --branco: #ecf0f1;
}

* {
  margin: 0 auto;
  padding: 0;
  box-sizing: border-box;
}

body {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  min-height: 100vh;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  color: white;
}

.app-uno {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
  text-align: center;
}

.app-uno h1 {
  margin-bottom: 30px;
  font-size: 2.5em;
}

/* Cartas Básicas */
.carta {
  width: 80px;
  height: 120px;
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  padding: 8px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  position: relative;
  overflow: hidden;
}

.carta::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255,255,255,0.1);
  border-radius: 6px;
}

/* Cores das cartas */
.carta-vermelho { background: var(--vermelho); color: white; }
.carta-azul { background: var(--azul); color: white; }
.carta-verde { background: var(--verde); color: white; }
.carta-amarelo { background: var(--amarelo); color: #2c3e50; }

.carta-topo, .carta-base {
  display: flex;
  justify-content: flex-start;
  font-weight: bold;
  font-size: 0.9em;
}

.carta-base {
  justify-content: flex-end;
}

.carta-centro {
  display: flex;
  justify-content: center;
  align-items: center;
  flex: 1;
  font-size: 2em;
  font-weight: bold;
}

.area-teste {
  display: flex;
  justify-content: center;
  gap: 20px;
  flex-wrap: wrap;
}</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>
        </div>

        <!-- PASSO 6: BARALHO COMPLETO -->
        <div class="implementation-step">
          <h3>Passo 6: Criando o Baralho Completo</h3>
          <p>
            Vamos atualizar <code>types/gametypes.ts</code> para incluir o
            baralho:
          </p>

          <div class="code-container">
            <pre>
// ... tipos anteriores ...

// Baralho simplificado - apenas números
export const BARALHO_COMPLETO: Carta[] = [];

// Cores disponíveis
const cores: Cor[] = ['vermelho', 'azul', 'verde', 'amarelo'];

// Criar cartas numeradas (0-9) para cada cor
cores.forEach(cor => {
  // Uma carta 0 de cada cor
  BARALHO_COMPLETO.push({
    id: `${cor}-0`,
    cor,
    valor: '0'
  });

  // Duas cartas de 1-9 para cada cor
  for (let i = 1; i <= 9; i++) {
    BARALHO_COMPLETO.push(
      {
        id: `${cor}-${i}-1`,
        cor,
        valor: i.toString() as ValorCarta,
      },
      {
        id: `${cor}-${i}-2`,
        cor,
        valor: i.toString() as ValorCarta,
      }
    );
  }
});</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>
        </div>

        <!-- PASSO 7: REDUCER INICIAL -->
        <div class="implementation-step">
          <h3>Passo 7: Reducer Básico - Iniciar Jogo</h3>
          <p>Crie <code>context/unoReducer.ts</code> com a ação básica:</p>

          <div class="code-container">
            <pre>
// context/unoReducer.ts
import type { EstadoJogo, Carta, Jogador } from '../types/gametypes';
import { BARALHO_COMPLETO } from '../types/gametypes';

type AcaoUno =
  | { type: 'INICIAR_JOGO' };

export function unoReducer(state: EstadoJogo, action: AcaoUno): EstadoJogo {
  switch (action.type) {
    case 'INICIAR_JOGO':
      return iniciarJogo();
    
    default:
      return state;
  }
}

function iniciarJogo(): EstadoJogo {
  // Embaralhar baralho
  const baralhoEmbaralhado = [...BARALHO_COMPLETO].sort(() => Math.random() - 0.5);
  
  // Distribuir 7 cartas para cada jogador (2 jogadores humanos)
  const jogadores: Jogador[] = [
    {
      id: 'jogador-1',
      nome: 'Jogador 1',
      mao: baralhoEmbaralhado.splice(0, 7),
      isHumano: true
    },
    {
      id: 'jogador-2',
      nome: 'Jogador 2',
      mao: baralhoEmbaralhado.splice(0, 7),
      isHumano: true
    }
  ];

  // Primeira carta do descarte
  const cartaInicial = baralhoEmbaralhado.pop()!;

  return {
    jogadores,
    monteCompra: baralhoEmbaralhado,
    monteDescarte: [cartaInicial],
    vez: 0, // Jogador 1 começa
    corAtual: cartaInicial.cor,
    vencedor: null,
    estado: 'jogando'
  };
}</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>
        </div>

        <!-- PASSO 8: APP COM REDUCER -->
        <div class="implementation-step">
          <h3>Passo 8: App com useReducer</h3>
          <p>Atualize <code>App.tsx</code> para usar o reducer:</p>

          <div class="code-container">
            <pre>
// App.tsx - COM REDUCER
import { useReducer } from 'react';
import { unoReducer } from './context/unoReducer';
import { CartaUno } from './components/CartaUno';
import './App.css';

function App() {
  const [state, dispatch] = useReducer(unoReducer, {
    jogadores: [],
    monteCompra: [],
    monteDescarte: [],
    vez: 0,
    corAtual: 'vermelho',
    vencedor: null,
    estado: 'preparacao'
  });

  // Iniciar jogo automaticamente
  if (state.estado === 'preparacao') {
    dispatch({ type: 'INICIAR_JOGO' });
  }

  return (
    &lt;div className="app-uno"&gt;
      &lt;h1&gt;🎮 UNO Simplificado&lt;/h1&gt;
      
      &lt;div className="info-jogo"&gt;
        &lt;p&gt;Vez: {state.jogadores[state.vez]?.nome}&lt;/p&gt;
        &lt;p&gt;Cor atual: {state.corAtual}&lt;/p&gt;
      &lt;/div&gt;

      &lt;div className="area-jogo"&gt;
        {/* Jogador 1 */}
        &lt;div className="jogador-area"&gt;
          &lt;h2&gt;{state.jogadores[0]?.nome}&lt;/h2&gt;
          &lt;div className="mao-jogador"&gt;
            {state.jogadores[0]?.mao.map((carta) => (
              &lt;CartaUno key={carta.id} carta={carta} /&gt;
            ))}
          &lt;/div&gt;
        &lt;/div&gt;

        {/* Mesa Central */}
        &lt;div className="mesa-central"&gt;
          &lt;h3&gt;Mesa&lt;/h3&gt;
          {state.monteDescarte[0] && (
            &lt;CartaUno carta={state.monteDescarte[0]} /&gt;
          )}
          &lt;p&gt;Monte de compra: {state.monteCompra.length} cartas&lt;/p&gt;
        &lt;/div&gt;

        {/* Jogador 2 */}
        &lt;div className="jogador-area"&gt;
          &lt;h2&gt;{state.jogadores[1]?.nome}&lt;/h2&gt;
          &lt;div className="mao-jogador"&gt;
            {state.jogadores[1]?.mao.map((carta) => (
              &lt;CartaUno key={carta.id} carta={carta} /&gt;
            ))}
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

export default App;</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>
        </div>

        <!-- PASSO 9: ESTILOS DO JOGO -->
        <div class="implementation-step">
          <h3>Passo 9: Estilos do Layout do Jogo</h3>
          <p>Atualize <code>App.css</code> para o layout do jogo:</p>

          <div class="code-container">
            <pre>
/* ... estilos anteriores ... */

.app-uno {
  max-width: 1000px;
  margin: 0 auto;
  padding: 20px;
  min-height: 100vh;
}

.header-uno {
  text-align: center;
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(255,255,255,0.1);
  border-radius: 15px;
}

.info-jogo {
  display: flex;
  justify-content: center;
  gap: 30px;
  font-size: 1.2em;
  margin-bottom: 20px;
}

/* Área do Jogo */
.area-jogo {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

/* Jogadores */
.jogador-area {
  text-align: center;
  padding: 15px;
  background: rgba(255,255,255,0.1);
  border-radius: 15px;
}

.jogador-area h2 {
  margin-bottom: 15px;
}

.mao-jogador {
  display: flex;
  justify-content: center;
  gap: 8px;
  flex-wrap: wrap;
  margin-bottom: 10px;
}

/* Mesa Central */
.mesa-central {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 15px;
  padding: 20px;
  background: rgba(255,255,255,0.05);
  border-radius: 15px;
}</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>
        </div>

        <!-- PASSO 10: COMPONENTE MESA -->
        <div class="implementation-step">
          <h3>Passo 10: Componente Mesa UNO</h3>
          <p>Crie <code>components/MesaUno.tsx</code>:</p>

          <div class="code-container">
            <pre>
// components/MesaUno.tsx
import type { Carta } from '../types/gametypes';
import { CartaUno } from './CartaUno';

interface MesaUnoProps {
  cartaTopo: Carta;
  corAtual: string;
  monteCompra: Carta[];
  onComprarCarta: () => void;
}

export function MesaUno({ cartaTopo, corAtual, monteCompra, onComprarCarta }: MesaUnoProps) {
  return (
    &lt;div className="mesa-uno"&gt;
      &lt;div className="area-monte"&gt;
        &lt;div className="monte-descarte"&gt;
          &lt;CartaUno carta={cartaTopo} /&gt;
          &lt;div className="cor-atual"&gt;
            Cor atual: &lt;span className={`cor-${corAtual}`}&gt;{corAtual}&lt;/span&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div className="monte-compra" onClick={onComprarCarta}&gt;
          &lt;div className="carta-virada"&gt;
            &lt;div className="carta-verso"&gt;
              &lt;div className="logo-uno"&gt;UNO&lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;div className="texto-comprar"&gt;Comprar ({monteCompra.length})&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>
        </div>

        <!-- PASSO 11: CARTA INTERATIVA -->
        <div class="implementation-step">
          <h3>Passo 11: Carta Interativa</h3>
          <p>Atualize <code>CartaUno.tsx</code> para ser interativa:</p>

          <div class="code-container">
            <pre>
// components/CartaUno.tsx - INTERATIVA
import type { Carta } from '../types/gametypes';

interface CartaUnoProps {
  carta: Carta;
  onClick?: () => void;
  selecionada?: boolean;
  jogavel?: boolean;
  virada?: boolean;
}

export function CartaUno({ carta, onClick, selecionada = false, jogavel = true, virada = false }: CartaUnoProps) {
  if (virada) {
    return (
      &lt;div className="carta carta-virada"&gt;
        &lt;div className="carta-verso"&gt;
          &lt;div className="logo-uno"&gt;UNO&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }

  return (
    &lt;div
      className={`carta carta-${carta.cor} ${selecionada ? 'carta-selecionada' : ''} ${!jogavel ? 'carta-inativa' : ''}`}
      onClick={jogavel ? onClick : undefined}
    &gt;
      &lt;div className="carta-topo"&gt;
        &lt;span className="carta-valor-pequeno"&gt;{carta.valor}&lt;/span&gt;
      &lt;/div&gt;
      
      &lt;div className="carta-centro"&gt;
        &lt;span className="carta-valor-grande"&gt;{carta.valor}&lt;/span&gt;
      &lt;/div&gt;
      
      &lt;div className="carta-base"&gt;
        &lt;span className="carta-valor-pequeno"&gt;{carta.valor}&lt;/span&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>
        </div>

        <!-- PASSO 12: LÓGICA DE JOGAR CARTA -->
        <div class="implementation-step">
          <h3>Passo 12: Lógica de Jogar Carta</h3>
          <p>Atualize o reducer para incluir jogar carta:</p>

          <div class="code-container">
            <pre>
// context/unoReducer.ts - ATUALIZADO
// ... imports e tipos anteriores ...

type AcaoUno =
  | { type: 'INICIAR_JOGO' }
  | { type: 'JOGAR_CARTA'; carta: Carta; jogadorIndex: number };

export function unoReducer(state: EstadoJogo, action: AcaoUno): EstadoJogo {
  switch (action.type) {
    case 'INICIAR_JOGO':
      return iniciarJogo();
    
    case 'JOGAR_CARTA':
      return jogarCarta(state, action.carta, action.jogadorIndex);
    
    default:
      return state;
  }
}

// ... função iniciarJogo anterior ...

function jogarCarta(state: EstadoJogo, carta: Carta, jogadorIndex: number): EstadoJogo {
  if (jogadorIndex !== state.vez) return state;
  
  const jogador = state.jogadores[jogadorIndex];
  
  // Verificar se a carta é jogável
  if (!podeJogarCarta(carta, state.monteDescarte[0], state.corAtual)) {
    return state;
  }

  // Remover carta da mão do jogador
  const novaMao = jogador.mao.filter(c => c.id !== carta.id);
  const novosJogadores = [...state.jogadores];
  novosJogadores[jogadorIndex] = { ...jogador, mao: novaMao };

  // Adicionar carta ao descarte
  const novoDescarte = [carta, ...state.monteDescarte];

  // Verificar vitória
  if (novaMao.length === 0) {
    return {
      ...state,
      jogadores: novosJogadores,
      monteDescarte: novoDescarte,
      vencedor: jogador,
      estado: 'finalizado'
    };
  }

  // Passar para o próximo jogador
  const proximaVez = (state.vez + 1) % state.jogadores.length;

  return {
    ...state,
    jogadores: novosJogadores,
    monteDescarte: novoDescarte,
    vez: proximaVez,
    corAtual: carta.cor
  };
}

function podeJogarCarta(carta: Carta, cartaTopo: Carta, corAtual: string): boolean {
  // Mesma cor ou mesmo valor
  return carta.cor === corAtual || carta.valor === cartaTopo.valor;
}</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>
        </div>

        <!-- PASSO 13: APP INTERATIVO -->
        <div class="implementation-step">
          <h3>Passo 13: App Interativo</h3>
          <p>Atualize <code>App.tsx</code> para ser interativo:</p>

          <div class="code-container">
            <pre>
// App.tsx - INTERATIVO
import { useReducer } from 'react';
import { unoReducer } from './context/unoReducer';
import { CartaUno } from './components/CartaUno';
import { MesaUno } from './components/MesaUno';
import './App.css';

function App() {
  const [state, dispatch] = useReducer(unoReducer, {
    jogadores: [],
    monteCompra: [],
    monteDescarte: [],
    vez: 0,
    corAtual: 'vermelho',
    vencedor: null,
    estado: 'preparacao'
  });

  // Iniciar jogo automaticamente
  if (state.estado === 'preparacao') {
    dispatch({ type: 'INICIAR_JOGO' });
  }

  const jogadorAtual = state.jogadores[state.vez];
  const cartaTopo = state.monteDescarte[0];

  const handleJogarCarta = (carta: any, jogadorIndex: number) => {
    if (jogadorIndex === state.vez) {
      dispatch({ type: 'JOGAR_CARTA', carta, jogadorIndex });
    }
  };

  const podeJogarCarta = (carta: any) => {
    return carta.cor === state.corAtual || carta.valor === cartaTopo.valor;
  };

  return (
    &lt;div className="app-uno"&gt;
      &lt;header className="header-uno"&gt;
        &lt;h1&gt;🎮 UNO Simplificado&lt;/h1&gt;
        &lt;div className="info-jogo"&gt;
          &lt;span&gt;Vez: &lt;strong&gt;{jogadorAtual?.nome}&lt;/strong&gt;&lt;/span&gt;
          &lt;span&gt;Cor atual: &lt;span className={`cor-${state.corAtual}`}&gt;{state.corAtual}&lt;/span&gt;&lt;/span&gt;
        &lt;/div&gt;
      &lt;/header&gt;

      &lt;div className="area-jogo"&gt;
        {/* Jogador 2 */}
        &lt;div className={`jogador-area ${state.vez === 1 ? 'jogador-ativo' : ''}`}&gt;
          &lt;h2&gt;{state.jogadores[1]?.nome}&lt;/h2&gt;
          &lt;div className="mao-jogador"&gt;
            {state.jogadores[1]?.mao.map((carta) => (
              &lt;CartaUno
                key={carta.id}
                carta={carta}
                jogavel={podeJogarCarta(carta) && state.vez === 1}
              /&gt;
            ))}
          &lt;/div&gt;
        &lt;/div&gt;

        {/* Mesa Central */}
        &lt;div className="mesa-central"&gt;
          &lt;MesaUno
            cartaTopo={cartaTopo}
            corAtual={state.corAtual}
            monteCompra={state.monteCompra}
            onComprarCarta={() => {}} // Por enquanto vazio
          /&gt;
        &lt;/div&gt;

        {/* Jogador 1 */}
        &lt;div className={`jogador-area ${state.vez === 0 ? 'jogador-ativo' : ''}`}&gt;
          &lt;h2&gt;{state.jogadores[0]?.nome}&lt;/h2&gt;
          &lt;div className="mao-jogador"&gt;
            {state.jogadores[0]?.mao.map((carta) => (
              &lt;CartaUno
                key={carta.id}
                carta={carta}
                onClick={() => handleJogarCarta(carta, 0)}
                jogavel={podeJogarCarta(carta) && state.vez === 0}
              /&gt;
            ))}
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

export default App;</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>
        </div>

        <!-- PASSO 14: COMPRAR CARTAS -->
        <div class="implementation-step">
          <h3>Passo 14: Lógica de Comprar Cartas</h3>
          <p>Complete o reducer com a ação de comprar carta:</p>

          <div class="code-container">
            <pre>
// context/unoReducer.ts
import type { EstadoJogo, Carta, Jogador } from '../types/gametypes';
import { BARALHO_COMPLETO } from '../types/gametypes';

type AcaoUno =
  | { type: 'INICIAR_JOGO' }
  | { type: 'JOGAR_CARTA'; carta: Carta; jogadorIndex: number }
  | { type: 'COMPRAR_CARTA'; jogadorIndex: number };

export function unoReducer(state: EstadoJogo, action: AcaoUno): EstadoJogo {
  switch (action.type) {
    case 'INICIAR_JOGO':
      return iniciarJogo();
    
    case 'JOGAR_CARTA':
      return jogarCarta(state, action.carta, action.jogadorIndex);
    
    case 'COMPRAR_CARTA':
      return comprarCarta(state, action.jogadorIndex);
    
    default:
      return state;
  }
}

function iniciarJogo(): EstadoJogo {
  // Embaralhar baralho
  const baralhoEmbaralhado = [...BARALHO_COMPLETO].sort(() => Math.random() - 0.5);
  
  // Distribuir 7 cartas para cada jogador (2 jogadores humanos)
  const jogadores: Jogador[] = [
    {
      id: 'jogador-1',
      nome: 'Jogador 1',
      mao: baralhoEmbaralhado.splice(0, 7),
      isHumano: true
    },
    {
      id: 'jogador-2',
      nome: 'Jogador 2',
      mao: baralhoEmbaralhado.splice(0, 7),
      isHumano: true
    }
  ];

  // Primeira carta do descarte
  const cartaInicial = baralhoEmbaralhado.pop()!;

  return {
    jogadores,
    monteCompra: baralhoEmbaralhado,
    monteDescarte: [cartaInicial],
    vez: 0, // Jogador 1 começa
    corAtual: cartaInicial.cor,
    vencedor: null,
    estado: 'jogando'
  };
}

function jogarCarta(state: EstadoJogo, carta: Carta, jogadorIndex: number): EstadoJogo {
  if (jogadorIndex !== state.vez) return state;
  
  const jogador = state.jogadores[jogadorIndex];
  
  // Verificar se a carta é jogável
  if (!podeJogarCarta(carta, state.monteDescarte[0], state.corAtual)) {
    return state;
  }

  // Remover carta da mão do jogador
  const novaMao = jogador.mao.filter(c => c.id !== carta.id);
  const novosJogadores = [...state.jogadores];
  novosJogadores[jogadorIndex] = { ...jogador, mao: novaMao };

  // Adicionar carta ao descarte
  const novoDescarte = [carta, ...state.monteDescarte];

  // Verificar vitória
  if (novaMao.length === 0) {
    return {
      ...state,
      jogadores: novosJogadores,
      monteDescarte: novoDescarte,
      vencedor: jogador,
      estado: 'finalizado'
    };
  }

  // Passar para o próximo jogador
  const proximaVez = (state.vez + 1) % state.jogadores.length;

  return {
    ...state,
    jogadores: novosJogadores,
    monteDescarte: novoDescarte,
    vez: proximaVez,
    corAtual: carta.cor
  };
}

function comprarCarta(state: EstadoJogo, jogadorIndex: number): EstadoJogo {
  if (jogadorIndex !== state.vez) return state;
  
  const jogador = state.jogadores[jogadorIndex];
  
  // Verificar se há cartas no monte de compra
  if (state.monteCompra.length === 0) {
    // Se não há cartas, reembaralhar o descarte (exceto a carta do topo)
    const [cartaTopo, ...restoDescarte] = state.monteDescarte;
    const novoMonteCompra = [...restoDescarte].sort(() => Math.random() - 0.5);
    const novoDescarte = [cartaTopo];
    
    return {
      ...state,
      monteCompra: novoMonteCompra,
      monteDescarte: novoDescarte
    };
  }

  // Comprar uma carta
  const cartaComprada = state.monteCompra.pop()!;
  const novaMao = [...jogador.mao, cartaComprada];
  const novosJogadores = [...state.jogadores];
  novosJogadores[jogadorIndex] = { ...jogador, mao: novaMao };

  // Passar a vez automaticamente após comprar
  const proximaVez = (state.vez + 1) % state.jogadores.length;

  return {
    ...state,
    jogadores: novosJogadores,
    monteCompra: [...state.monteCompra],
    vez: proximaVez
  };
}

function podeJogarCarta(carta: Carta, cartaTopo: Carta, corAtual: string): boolean {
  // Mesma cor ou mesmo valor
  return carta.cor === corAtual || carta.valor === cartaTopo.valor;
}</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>
        </div>

        <!-- PASSO 15: APP COMPLETO -->
        <div class="implementation-step">
          <h3>Passo 15: App Completo</h3>
          <p>Finalize <code>App.tsx</code> com todas as funcionalidades:</p>

          <div class="code-container">
            <pre>
// App.tsx - COMPLETO
import { useReducer } from 'react';
import { unoReducer } from './context/unoReducer';
import { CartaUno } from './components/CartaUno';
import { MesaUno } from './components/MesaUno';
import './App.css';

function App() {
  const [state, dispatch] = useReducer(unoReducer, {
    jogadores: [],
    monteCompra: [],
    monteDescarte: [],
    vez: 0,
    corAtual: 'vermelho',
    vencedor: null,
    estado: 'preparacao'
  });

  // Iniciar jogo automaticamente
  if (state.estado === 'preparacao') {
    dispatch({ type: 'INICIAR_JOGO' });
  }

  const jogadorAtual = state.jogadores[state.vez];
  const cartaTopo = state.monteDescarte[0];

  const handleJogarCarta = (carta: any, jogadorIndex: number) => {
    if (jogadorIndex === state.vez) {
      dispatch({ type: 'JOGAR_CARTA', carta, jogadorIndex });
    }
  };

  const handleComprarCarta = (jogadorIndex: number) => {
    if (jogadorIndex === state.vez) {
      dispatch({ type: 'COMPRAR_CARTA', jogadorIndex });
    }
  };

  const podeJogarCarta = (carta: any) => {
    return carta.cor === state.corAtual || carta.valor === cartaTopo.valor;
  };

  if (state.vencedor) {
    return (
      &lt;div className="tela-vitoria"&gt;
        &lt;div className="vitoria-container"&gt;
          &lt;h1&gt;{state.vencedor.nome} Venceu!&lt;/h1&gt;
          &lt;p&gt;Parabéns!&lt;/p&gt;
          &lt;button 
            onClick={() => dispatch({ type: 'INICIAR_JOGO' })}
            className="btn-principal"
          &gt;
            Jogar Novamente
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }

  return (
    &lt;div className="app-uno"&gt;
      &lt;header className="header-uno"&gt;
        &lt;h1&gt;🎮 UNO Simplificado&lt;/h1&gt;
        &lt;div className="info-jogo"&gt;
          &lt;span&gt;Vez: &lt;strong&gt;{jogadorAtual?.nome}&lt;/strong&gt;&lt;/span&gt;
          &lt;span&gt;Cor atual: &lt;span className={`cor-${state.corAtual}`}&gt;{state.corAtual}&lt;/span&gt;&lt;/span&gt;
        &lt;/div&gt;
      &lt;/header&gt;

      &lt;div className="area-jogo"&gt;
        {/* Jogador 2 */}
        &lt;div className={`jogador-area ${state.vez === 1 ? 'jogador-ativo' : ''}`}&gt;
          &lt;h2&gt;{state.jogadores[1]?.nome}&lt;/h2&gt;
          &lt;div className="mao-jogador"&gt;
            {state.jogadores[1]?.mao.map((carta) => (
              &lt;CartaUno
                key={carta.id}
                carta={carta}
                onClick={() => handleJogarCarta(carta, 1)}
                jogavel={podeJogarCarta(carta) && state.vez === 1}
              /&gt;
            ))}
          &lt;/div&gt;
          &lt;div className="contador-cartas"&gt;
            {state.jogadores[1]?.mao.length} cartas
          &lt;/div&gt;
          {state.vez === 1 && (
            &lt;button onClick={() => handleComprarCarta(1)} className="btn-comprar"&gt;
              Comprar Carta
            &lt;/button&gt;
          )}
        &lt;/div&gt;

        {/* Mesa Central */}
        &lt;div className="mesa-central"&gt;
          &lt;MesaUno
            cartaTopo={cartaTopo}
            corAtual={state.corAtual}
            monteCompra={state.monteCompra}
            onComprarCarta={() => handleComprarCarta(state.vez)}
          /&gt;
        &lt;/div&gt;

        {/* Jogador 1 */}
        &lt;div className={`jogador-area ${state.vez === 0 ? 'jogador-ativo' : ''}`}&gt;
          &lt;h2&gt;{state.jogadores[0]?.nome}&lt;/h2&gt;
          &lt;div className="mao-jogador"&gt;
            {state.jogadores[0]?.mao.map((carta) => (
              &lt;CartaUno
                key={carta.id}
                carta={carta}
                onClick={() => handleJogarCarta(carta, 0)}
                jogavel={podeJogarCarta(carta) && state.vez === 0}
              /&gt;
            ))}
          &lt;/div&gt;
          &lt;div className="contador-cartas"&gt;
            {state.jogadores[0]?.mao.length} cartas
          &lt;/div&gt;
          {state.vez === 0 && (
            &lt;button onClick={() => handleComprarCarta(0)} className="btn-comprar"&gt;
              Comprar Carta
            &lt;/button&gt;
          )}
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

export default App;</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>
        </div>

        <!-- PASSO 16: ESTILOS COMPLETOS -->
        <div class="implementation-step">
          <h3>Passo 16: Estilos Completos</h3>
          <p>Adicione os estilos finais em <code>App.css</code>:</p>

          <div class="code-container">
            <pre>
/* App.css - UNO Simplificado */
:root {
  --vermelho: #e74c3c;
  --azul: #3498db;
  --verde: #2ecc71;
  --amarelo: #f1c40f;
  --preto: #2c3e50;
  --branco: #ecf0f1;
}

* {
  margin: 0 auto;
  padding: 0;
  box-sizing: border-box;
}

body {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  min-height: 100vh;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  color: white;
}

.app-uno {
  max-width: 1000px;
  margin: 0 auto;
  padding: 20px;
  min-height: 100vh;
}

/* Header */
.header-uno {
  text-align: center;
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(255,255,255,0.1);
  border-radius: 15px;
}

.header-uno h1 {
  font-size: 2.5em;
  margin-bottom: 10px;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
}

.info-jogo {
  display: flex;
  justify-content: center;
  gap: 30px;
  font-size: 1.2em;
}

/* Área do Jogo */
.area-jogo-uno {
  display: flex;
  flex-direction: column;
  gap: 20px;
  flex: 1;
}

/* Jogadores */
.jogador-area {
  text-align: center;
  padding: 15px;
  background: rgba(255,255,255,0.1);
  border-radius: 15px;
  transition: all 0.3s ease;
}

.jogador-ativo {
  background: rgba(255,255,255,0.2);
  border: 2px solid rgba(255,255,255,0.3);
}

.jogador-area h2 {
  margin-bottom: 15px;
  font-size: 1.5em;
}

.mao-jogador {
  display: flex;
  justify-content: center;
  gap: 8px;
  flex-wrap: wrap;
  margin-bottom: 10px;
}

.contador-cartas {
  font-weight: bold;
  font-size: 1.1em;
  margin-bottom: 10px;
}

/* Mesa Central */
.mesa-central {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 150px;
}

.mesa-uno {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 15px;
}

.area-monte {
  display: flex;
  gap: 20px;
  align-items: center;
}

.monte-descarte, .monte-compra {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.cor-atual {
  font-weight: bold;
  font-size: 1.1em;
}

.cor-vermelho { color: var(--vermelho); }
.cor-azul { color: var(--azul); }
.cor-verde { color: var(--verde); }
.cor-amarelo { color: var(--amarelo); }

.texto-comprar {
  font-weight: bold;
  cursor: pointer;
}

/* Cartas */
.carta {
  width: 70px;
  height: 100px;
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  padding: 6px;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  position: relative;
  overflow: hidden;
}

.carta::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255,255,255,0.1);
  border-radius: 6px;
}

.carta-virada {
  background: linear-gradient(45deg, #e74c3c, #3498db);
}

.carta-verso {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, #e74c3c, #3498db, #2ecc71, #f1c40f);
  border-radius: 6px;
}

.logo-uno {
  font-size: 1.5em;
  font-weight: bold;
  color: white;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}

/* Cores das cartas */
.carta-vermelho { background: var(--vermelho); color: white; }
.carta-azul { background: var(--azul); color: white; }
.carta-verde { background: var(--verde); color: white; }
.carta-amarelo { background: var(--amarelo); color: #2c3e50; }

.carta-topo, .carta-base {
  display: flex;
  justify-content: flex-start;
  font-weight: bold;
  font-size: 0.9em;
}

.carta-base {
  justify-content: flex-end;
}

.carta-centro {
  display: flex;
  justify-content: center;
  align-items: center;
  flex: 1;
  font-size: 1.8em;
  font-weight: bold;
}

.carta-selecionada {
  transform: translateY(-10px);
  box-shadow: 0 8px 16px rgba(0,0,0,0.3);
}

.carta-inativa {
  opacity: 0.6;
  cursor: not-allowed;
}

/* Botões */
.btn-comprar, .btn-principal {
  background: linear-gradient(135deg, #667eea, #764ba2);
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 25px;
  font-size: 1em;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 4px 15px rgba(0,0,0,0.2);
}

.btn-comprar:hover, .btn-principal:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(0,0,0,0.3);
}

/* Tela de Vitória */
.tela-vitoria {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

.vitoria-container {
  text-align: center;
  max-width: 500px;
  padding: 40px;
  background: rgba(255,255,255,0.1);
  backdrop-filter: blur(10px);
  border-radius: 20px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.1);
}

.tela-vitoria h1 {
  font-size: 3em;
  margin-bottom: 20px;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
}

/* Responsividade */
@media (max-width: 768px) {
  .carta {
    width: 60px;
    height: 90px;
  }
  
  .carta-centro {
    font-size: 1.4em;
  }
  
  .mao-jogador {
    gap: 5px;
  }
  
  .area-monte {
    gap: 15px;
  }
  
  .header-uno h1 {
    font-size: 2em;
  }
  
  .info-jogo {
    flex-direction: column;
    gap: 10px;
  }
}</pre
            >
            <button class="copy-btn no-print">Copiar</button>
          </div>
        </div>

        <div class="implementation-complete">
          <h3>🎉 UNO Simplificado Concluído!</h3>

          <div class="success-checklist">
            <h4>O Que Aprendemos Passo a Passo:</h4>
            <ul>
              <li>
                <strong>Passo 1-2</strong>: Estrutura do projeto e tipos
                TypeScript
              </li>
              <li>
                <strong>Passo 3-5</strong>: Componente Carta básico e estilos
                iniciais
              </li>
              <li>
                <strong>Passo 6-7</strong>: Baralho completo e reducer inicial
              </li>
              <li>
                <strong>Passo 8-9</strong>: App com useReducer e layout básico
              </li>
              <li>
                <strong>Passo 10-11</strong>: Componente Mesa e cartas
                interativas
              </li>
              <li>
                <strong>Passo 12-13</strong>: Lógica de jogar carta e app
                interativo
              </li>
              <li>
                <strong>Passo 14-15</strong>: Comprar cartas e app completo
              </li>
              <li><strong>Passo 16</strong>: Estilos finais e polimento</li>
            </ul>
          </div>
        </div>
      </section>

      <!-- CONCLUSÃO -->
      <section id="conclusao" class="main-section">
        <h2>Conclusão do Minicurso</h2>

        <div class="achievement-summary">
          <h3>O Que Aprendemos</h3>
          <div class="learned-grid">
            <div class="learned-item">
              <h4>Conceitos Fundamentais</h4>
              <ul>
                <li>TypeScript e tipagem estática</li>
                <li>Arquitetura baseada em componentes</li>
                <li>Props e comunicação entre componentes</li>
                <li>Estado local e global</li>
                <li>Hooks do React (useState, useEffect, useReducer)</li>
              </ul>
            </div>

            <div class="learned-item">
              <h4>Implementação Prática</h4>
              <ul>
                <li>Modelagem de dados do jogo</li>
                <li>Sistema de cartas e recursos</li>
                <li>Lógica de turnos e ações</li>
                <li>Condições de vitória</li>
                <li>Interface de usuário intuitiva</li>
              </ul>
            </div>
          </div>
        </div>

        <div class="final-message">
          <h3>Parabéns pela Conclusão!</h3>
          <p>Você deu um grande passo no mundo do desenvolvimento React!</p>
          <p>Colocar aqui formulario de avaliacao</p>
        </div>
      </section>

      <button class="print-btn no-print" onclick="window.print()">
        <p class="no-print">Gerar PDF</p>
      </button>
    </main>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        // Selecionar todos os containers de código
        const codeContainers = document.querySelectorAll(".code-container");

        // Para cada container de código
        codeContainers.forEach((container) => {
          // Encontrar o botão de cópia dentro do container
          const copyBtn = container.querySelector(".copy-btn");
          // Encontrar o bloco de código dentro do container
          const codeBlock = container.querySelector("pre");

          // Adicionar evento de clique ao botão de cópia
          copyBtn.addEventListener("click", () => {
            // Obter o texto do bloco de código
            const code = codeBlock.textContent;

            // Copiar para a área de transferência
            navigator.clipboard
              .writeText(code)
              .then(() => {
                // Feedback visual
                copyBtn.textContent = "Copiado!";
                copyBtn.classList.add("copied");

                // Resetar após 2 segundos
                setTimeout(() => {
                  copyBtn.textContent = "Copiar";
                  copyBtn.classList.remove("copied");
                }, 2000);
              })
              .catch((err) => {
                console.error("Falha ao copiar: ", err);
                copyBtn.textContent = "Erro ao copiar";
              });
          });
        });

        // Navegação suave
        document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
          anchor.addEventListener("click", function (e) {
            e.preventDefault();

            const targetId = this.getAttribute("href");
            const targetElement = document.querySelector(targetId);

            if (targetElement) {
              targetElement.scrollIntoView({
                behavior: "smooth",
              });
            }
          });
        });
      });
    </script>
  </body>
</html>
